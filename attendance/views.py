from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf
# from .models import AdmitCardEligibility
from .models import AdmitCardEligibility



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller,
    AdmitCardEligibility

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



@login_required
@login_required
def download_admit_card(request):
    student_user = request.user
    student_enrollment = EnrollStudent.objects.filter(user=student_user).first()
    
    if not student_enrollment:
        messages.error(request, 'You are not enrolled in any program.')
        return redirect('student_dashboard')
    
    # Get the Student instance using enrollment details
    try:
        student = Student.objects.get(
            enrollment_no=student_user.username,
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        )
    except Student.DoesNotExist:
        messages.error(request, 'Student record not found. Please contact the administrator.')
        return redirect('student_dashboard')
    
    enrolled_courses = Course.objects.filter(
        enrollstudent__user=student_user,
        enrollstudent__semester=student_enrollment.semester
    )
    
    # Calculate overall attendance using the same method as student dashboard
    attendance_records = Attendance.objects.filter(
        student=student,
        course__in=enrolled_courses
    )
    
    total_classes = attendance_records.count()
    present_count = attendance_records.filter(status='Present').count()
    overall_attendance = (present_count / total_classes * 100) if total_classes > 0 else 0
    
    # Calculate per-course attendance for the PDF
    course_attendance_data = []
    for course in enrolled_courses:
        course_records = attendance_records.filter(course=course)
        if course_records.exists():
            course_total = course_records.count()
            course_present = course_records.filter(status='Present').count()
            attendance_percentage = (course_present / course_total * 100) if course_total > 0 else 0
            
            course_attendance_data.append({
                'course': course,
                'attendance_percentage': attendance_percentage
            })

    # Get the university-wide eligibility percentage
    try:
        eligibility_setting = AdmitCardEligibility.objects.first()
        required_percentage = eligibility_setting.percentage if eligibility_setting else 75
    except:
        required_percentage = 75

    if overall_attendance < required_percentage:
        messages.error(request, f'You are not eligible for an admit card. Your attendance is below {required_percentage}%.')
        return redirect('student_dashboard')
    
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="admit_card_{student_user.username}.pdf"'
    
    doc = SimpleDocTemplate(response, pagesize=letter)
    elements = []
    
    styles = getSampleStyleSheet()
    title_style = styles['Title']
    header_style = styles['Heading2']
    normal_style = styles['Normal']
    
    elements.append(Paragraph("UNIVERSITY ADMIT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", header_style))
    elements.append(Spacer(1, 20))
    
    student_data = [
        ["Student ID:", student_user.username],
        ["Full Name:", f"{student_user.first_name} {student_user.last_name}"],
        ["Email:", student_user.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))
    
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))
    
    course_data = [["Course Code", "Course Name", "Credit Hours", "Attendance %"]]
    for course_info in course_attendance_data:
        course = course_info['course']
        attendance_percentage = course_info['attendance_percentage']
        course_data.append([course.code, course.name, str(course.credit), f"{attendance_percentage:.2f}%"])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))
    
    elements.append(Paragraph(f"Overall Attendance: {overall_attendance:.2f}%", header_style))
    elements.append(Spacer(1, 20))
    
    elements.append(Paragraph("Student Signature:", normal_style))
    elements.append(Spacer(1, 50))
    elements.append(Paragraph("Controller Signature:", normal_style))
    elements.append(Spacer(1, 20))
    
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student_user.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()
    )
    elements.append(Paragraph(footer_text, normal_style))
    
    doc.build(elements)
    return response
    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response





# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response




# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response

from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response






# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


# ✅ Add Department
@login_required
def add_department(request):
    """Handles adding a new department."""
    if request.method == "POST":
        name = request.POST.get("name")
        if name:
            if Department.objects.filter(name=name).exists():
                messages.error(request, "Department already exists!")
            else:
                Department.objects.create(name=name)
                messages.success(request, "Department added successfully!")
                return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/add_department.html")


# ✅ Edit Department
@login_required
def edit_department(request, dept_id):
    """Handles editing an existing department."""
    department = get_object_or_404(Department, id=dept_id)

    if request.method == "POST":
        new_name = request.POST.get("name")
        if new_name:
            department.name = new_name
            department.save()
            messages.success(request, "Department updated successfully!")
            return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/edit_department.html", {"department": department})


# ✅ Delete Department
@login_required
def delete_department(request, dept_id):
    if not request.user.is_staff:
        messages.error(request, "Access Denied!")
        return redirect("home")

    department = get_object_or_404(Department, id=dept_id)
    department.delete()
    messages.success(request, "Department deleted successfully!")
    return redirect("manage_department")




# -----------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------ MANAGE_PROGRAM---------------------------------------------------------------#
# ✅ Manage Programs (List All)
from django.db import IntegrityError
from django.contrib import messages
from attendance.models import Program, Department, Semester

def manage_programs(request):
    departments = Department.objects.all()
    programs = Program.objects.select_related('department').all()

    if request.method == "POST":
        try:
            department_id = request.POST.get("department")
            program_name = request.POST.get("program_name")
            duration = int(request.POST.get("duration"))  # Convert to int safely
            num_semesters = int(request.POST.get("num_semesters"))  # Convert to int safely

            department = Department.objects.get(id=department_id)
            program = Program.objects.create(
                department=department, name=program_name, duration=duration, num_semesters=num_semesters
            )

            # Prevent duplicate semesters
            for i in range(1, num_semesters + 1):
                semester_name = "Semester " + str(i)  # Explicitly convert i to str
                if not Semester.objects.filter(program=program, name=semester_name).exists():
                    Semester.objects.create(program=program, name=semester_name)

            messages.success(request, "Program and semesters added successfully!")

        except IntegrityError:
            messages.error(request, "A program with the same name or semester name already exists in this department.")
        except ValueError:
            messages.error(request, "Invalid input: Duration and number of semesters must be numbers.")
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")

    return render(request, "attendance/manage_program_template/manage_programs.html", {"departments": departments, "programs": programs})



def delete_program(request, program_id):
    """Handles program deletion."""
    try:
        program = Program.objects.get(id=program_id)
        program.delete()
        messages.success(request, "Program deleted successfully!")
    except Program.DoesNotExist:
        messages.error(request, "Program not found.")

    return redirect("manage_programs")



def edit_program(request, program_id):
    program = get_object_or_404(Program, id=program_id)
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_name = request.POST.get("program_name")
        duration = request.POST.get("duration")
        num_semesters = request.POST.get("num_semesters")

        # Validate and save
        if department_id and program_name and duration and num_semesters:
            program.department_id = department_id
            program.name = program_name
            program.duration = duration
            program.num_semesters = num_semesters
            program.save()
            messages.success(request, "Program updated successfully!")
            return redirect("manage_programs")

    return render(request, "attendance/manage_program_template/edit_program.html", {"program": program, "departments": departments})



# ✅ Add Program
@login_required
def add_program(request):
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")  # Get selected department
        program_name = request.POST.get("program_name")  # Get program name

        if not department_id or not program_name:
            messages.error(request, "Please fill in all fields.")
            return render(request, "attendance/add_program.html", {"departments": departments})

        try:
            department = Department.objects.get(id=department_id)  # Fetch department
            Program.objects.create(name=program_name, department=department)  # Create new program
            messages.success(request, f"Program '{program_name}' added successfully!")
            return redirect("manage_programs")
        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")

    return render(request, "attendance/manage_program_template/add_program.html", {"departments": departments})






# ------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_SEMESTER------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Semester  # Ensure you have a Semester model
from .forms import SemesterForm  # Create a form for Semester model




# ✅ Manage Semesters (List All)

@login_required
def manage_semesters(request):
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()

    selected_department = request.GET.get('department')
    selected_program = request.GET.get('program')

    # Filter based on department and program
    if selected_department:
        programs = programs.filter(department_id=selected_department)
    if selected_program:
        semesters = semesters.filter(program_id=selected_program)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'selected_department': selected_department,
        'selected_program': selected_program,
    }
    return render(request, 'attendance/manage_semester_template/manage_semesters.html', context)



#-------------------------------------------------------------------------------------------------------------------------------------#
#-------------------------------------------------------MANAGE_COURSE-----------------------------------------------------------------#


# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

def manage_courses(request):
    """View to add, filter, and display courses."""
    departments = Department.objects.all()
    courses = Course.objects.all()

    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')

    # Get programs and semesters based on selected department
    programs = Program.objects.none()
    semesters = Semester.objects.none()

    if department_id:
        programs = Program.objects.filter(department_id=department_id)
        courses = courses.filter(department_id=department_id)
        
        if program_id:
            semesters = Semester.objects.filter(program_id=program_id)
            courses = courses.filter(program_id=program_id)
            
            if semester_id:
                courses = courses.filter(semester_id=semester_id)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'courses': courses,
        'selected_department': department_id,
        'selected_program': program_id,
        'selected_semester': semester_id
    }
    return render(request, 'attendance/manage_courses.html', context)

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

def edit_course(request, course_id):
    course = get_object_or_404(Course, id=course_id)
    departments = Department.objects.all()

    if request.method == 'POST':
        try:
            course.department_id = request.POST['department']
            course.program_id = request.POST['program']
            course.semester_id = request.POST['semester']
            course.code = request.POST['course_code']
            course.name = request.POST['course_name']
            course.credit = request.POST['course_credit']
            course.save()
            messages.success(request, f'Course "{course.name}" has been updated successfully!')
            return redirect('manage_courses')
        except Exception as e:
            messages.error(request, f'Error updating course: {str(e)}')
            return redirect('edit_course', course_id=course_id)

    context = {
        'course': course,
        'departments': departments,
    }
    return render(request, 'attendance/manage_course_template/edit_course.html', context)


def delete_course(request, course_id):
    """View to delete a course."""
    try:
        course = get_object_or_404(Course, id=course_id)
        course_name = course.name
        course.delete()
        messages.success(request, f'Course "{course_name}" has been deleted successfully!')
    except Exception as e:
        messages.error(request, f'Error deleting course: {str(e)}')
    return redirect("manage_courses")

def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)

def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)



#-------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_TEACHER-------------------------------------------------------------------#
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import Department, Teacher

def manage_teachers(request):
    departments = Department.objects.all()
    teachers = Teacher.objects.all()

    # Filtering by department
    department_id = request.GET.get('department')
    if department_id:
        teachers = teachers.filter(department_id=department_id)

    if request.method == "POST":
        teacher_code = request.POST.get('teacher_code')
        name = request.POST.get('name')
        department_id = request.POST.get('department')

        # Check if teacher_code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, "Teacher code already exists!")
        else:
            department = get_object_or_404(Department, id=department_id)
            teacher = Teacher.objects.create(teacher_code=teacher_code, name=name, department=department)
            messages.success(request, f"Teacher {teacher.name} (Code: {teacher.teacher_code}) added successfully!")
            return redirect('manage_teachers')

    return render(request, "attendance/manage_teacher_template/manage_teachers.html", {"departments": departments, "teachers": teachers})


def edit_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    departments = Department.objects.all()

    if request.method == "POST":
        teacher.teacher_code = request.POST.get("teacher_code")
        teacher.name = request.POST.get("name")
        department_id = request.POST.get("department")
        teacher.department = get_object_or_404(Department, id=department_id)
        teacher.save()
        messages.success(request, "Teacher details updated successfully!")
        return redirect("manage_teachers")

    return render(request, "attendance/manage_teacher_template/edit_teacher.html", {"teacher": teacher, "departments": departments})


def delete_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    teacher.delete()
    messages.success(request, "Teacher deleted successfully!")
    return redirect("manage_teachers")

#--------------------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------MANAGE_STUDENT-------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import JsonResponse
from .models import Student, Department, Program, Semester

def manage_students(request):
    """View to add, filter, and display students."""
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()
    students = Student.objects.all()

    # Handling student filtering logic
    department_filter = request.GET.get("department")
    program_filter = request.GET.get("program")
    semester_filter = request.GET.get("semester")

    if department_filter:
        students = students.filter(department_id=department_filter)
        programs = Program.objects.filter(department_id=department_filter)  # Fetch relevant programs

    if program_filter:
        students = students.filter(program_id=program_filter)
        semesters = Semester.objects.filter(program_id=program_filter)  # Fetch relevant semesters

    if semester_filter:
        students = students.filter(semester_id=semester_filter)

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_id = request.POST.get("program")
        semester_id = request.POST.get("semester")
        enrollment_no = request.POST.get("enrollment_no").strip()
        roll_no = request.POST.get("roll_no").strip()
        session = request.POST.get("session").strip()
        student_name = request.POST.get("student_name").strip()

        if not (department_id and program_id and semester_id and enrollment_no and roll_no and session and student_name):
            messages.error(request, "All fields are required.")
            return redirect("manage_students")

        department = get_object_or_404(Department, id=department_id)
        program = get_object_or_404(Program, id=program_id, department=department)  # Ensure program belongs to department
        semester = get_object_or_404(Semester, id=semester_id, program=program)  # Ensure semester belongs to program

        if Student.objects.filter(enrollment_no=enrollment_no).exists():
            messages.error(request, "Student with this enrollment number already exists.")
        else:
            student = Student.objects.create(
                department=department,
                program=program,
                semester=semester,
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                session=session,
                name=student_name,
            )
            messages.success(request, f"Student {student.name} (Enrollment No: {student.enrollment_no}) added successfully.")

        return redirect("manage_students")

    context = {
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
        "students": students,
        "selected_department": department_filter,
        "selected_program": program_filter,
        "selected_semester": semester_filter,
    }
    return render(request, "attendance/manage_student_template/manage_students.html", context)


def edit_student(request, student_id):
    """View to edit an existing student."""
    student = get_object_or_404(Student, id=student_id)
    departments = Department.objects.all()
    programs = Program.objects.filter(department=student.department)
    semesters = Semester.objects.filter(program=student.program)

    if request.method == "POST":
        student.department_id = request.POST["department"]
        student.program_id = request.POST["program"]
        student.semester_id = request.POST["semester"]
        student.enrollment_no = request.POST["enrollment_no"]
        student.roll_no = request.POST["roll_no"]
        student.session = request.POST["session"]
        student.name = request.POST["student_name"]
        student.save()
        messages.success(request, "Student updated successfully!")
        return redirect("manage_students")

    context = {
        "student": student,
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
    }
    return render(request, "attendance/manage_student_template/edit_student.html", context)

def delete_student(request, student_id):
    """View to delete a student."""
    student = get_object_or_404(Student, id=student_id)
    student.delete()
    messages.success(request, "Student deleted successfully.")
    return redirect("manage_students")


# AJAX Views for Dynamic Dropdowns
def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)


def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)


def get_programs_by_department(request, department_id):
    try:
        department = Department.objects.get(id=department_id)
        programs = Program.objects.filter(department=department)
        data = [{'id': program.id, 'name': program.name} for program in programs]
        return JsonResponse(data, safe=False)
    except Department.DoesNotExist:
        return JsonResponse([], safe=False)

def get_semesters_by_program(request, program_id=None):
    try:
        # Try to get program_id from query parameters if not in URL
        if program_id is None:
            program_id = request.GET.get('program_id')
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)







#-------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------ASSIGN_TEACHER------------------------------------------------------#

# ✅ Assign Teacher to Course (Admin Only)

from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from .forms import AssignTeacherForm
from .models import CourseTeacher














from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from .forms import AssignTeacherForm
from .models import CourseTeacher, Course, Program, Semester

@login_required
def mark_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        # Get current date and time in IST
        current_datetime = timezone.localtime(timezone.now())
        current_date = current_datetime.date()
        total_students = enrolled_students.count()
        present_count = 0
        absent_count = 0

        # Process attendance for each student
        for student in enrolled_students:
            # Default status is 'Absent', only change if explicitly marked as 'Present'
            status = request.POST.get(f'status_{student.id}', 'Absent')
            try:
                # Create or get Student instance
                student_instance, created = Student.objects.get_or_create(
                    name=student.user.get_full_name(),
                    department=course_teacher.department,
                    program=course_teacher.program,
                    semester=course_teacher.semester,
                    defaults={
                        'enrollment_no': student.user.username,
                        'roll_no': student.user.username
                    }
                )
                
                # Create attendance record with current date and time
                Attendance.objects.create(
                    course=course,
                    student=student_instance,
                    date=current_date,
                    status=status,
                    marked_at=current_datetime
                )
                if status == 'Present':
                    present_count += 1
                else:
                    absent_count += 1

                # --- Notification Logic ---
                # Calculate attendance percentage for this student in this course
                total_classes = Attendance.objects.filter(course=course, student=student_instance).count()
                present_classes = Attendance.objects.filter(course=course, student=student_instance, status='Present').count()
                attendance_percentage = (present_classes / total_classes) * 100 if total_classes > 0 else 0
                from attendance.models import Notification
                if attendance_percentage < 75:
                    message = f"You are requested to attend the classes of {course.name} because your attendance in this course is {attendance_percentage:.2f}%, which is lower than the 75% criteria."
                    Notification.objects.create(
                        user=student.user,
                        title=f"Low Attendance in {course.code}",
                        message=message,
                        notification_type='general',
                        is_read=False
                    )
            except Exception as e:
                messages.error(request, f"Error saving attendance for {student.user.get_full_name()}: {str(e)}")
                return redirect('mark_attendance', course_id=course_id)

        messages.success(request, f"Attendance marked successfully! Present: {present_count}, Absent: {absent_count}")
        return redirect('view_attendance', course_id=course_id)

    # Get current time in IST
    current_time = timezone.localtime(timezone.now())
    
    return render(request, 'attendance/teacher_authentication_template/mark_attendance.html', {
        'course': course,
        'enrolled_students': enrolled_students,
        'current_datetime': current_time
    })




# ------------------------------------------------------------------------------

import csv
from django.http import HttpResponse
from .models import Attendance

@login_required
def export_attendance(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="attendance.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Student', 'Course', 'Status', 'Date'])

    for record in Attendance.objects.all():
        writer.writerow([record.student.name, record.course.name, record.status, record.date])

    return response



# ----------------------------------------------------------------------------------

from django.http import JsonResponse
from .models import Semester, Program

def get_semesters(request):
    """Returns semesters based on selected program (for dynamic dropdown)."""
    program_id = request.GET.get("program_id")
    
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
        return JsonResponse(list(semesters), safe=False)
    
    return JsonResponse({"error": "Invalid Request"}, status=400)




# -----------------------------------------------------------------------------------
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages



from .forms import EnrollmentForm

def enroll_students(request):
    if request.method == "POST":
        form = EnrollmentForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('enroll_students')
    else:
        form = EnrollmentForm()
    return render(request, 'attendance/enroll_students.html', {'form': form})




from .models import Attendance

@login_required
def view_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Order by date descending and then by time descending
    attendance_records = attendance_records.order_by('-date', '-marked_at')

    # Calculate attendance statistics for each student
    attendance_summary = {}
    
    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()
    
    for student in students:
        # Get all attendance records for this student after filtering
        student_records = attendance_records.filter(student=student)
        
        # Count total classes for this student (unique date+marked_at combinations)
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        
        # Calculate attendance percentage
        percentage = round((present_count / total_classes * 100), 2) if total_classes > 0 else 0
        
        attendance_summary[student.id] = {
            'name': student.name,
            'present_count': present_count,
            'total_classes': total_classes,
            'percentage': percentage
        }

    # Get unique dates for the date filter dropdown
    unique_dates = attendance_records.values_list('date', flat=True).distinct().order_by('-date')
    
    # Get unique student names for the student filter dropdown
    unique_students = students.values_list('name', flat=True).order_by('name')

    return render(request, 'attendance/teacher_authentication_template/view_attendance.html', {
        'course': course,
        'attendance_records': attendance_records,
        'attendance_summary': attendance_summary,
        'unique_dates': unique_dates,
        'unique_students': unique_students,
        'selected_from_date': from_date,
        'selected_to_date': to_date,
        'selected_student': student_name,
        'selected_status': status
    })



def generate_reports(request):
    return render(request, 'attendance/generate_reports.html')




from django.shortcuts import render
from django.contrib.auth.decorators import login_required





# -----------------------------------------------------------------------------------------------------------------------

from django.shortcuts import render, redirect
from django.http import JsonResponse
from .models import CourseTeacher, Program, Semester, Course
from .forms import AssignTeacherForm

from django.shortcuts import render, redirect
from .forms import AssignTeacherForm
from .models import CourseTeacher

@login_required
def assign_teacher(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    if request.method == "POST":
        try:
            teacher_id = request.POST.get('teacher')
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_ids = request.POST.getlist('courses')

            if not all([teacher_id, department_id, program_id, semester_id, course_ids]):
                messages.error(request, "All fields are required.")
                return redirect('assign_teacher')

            teacher = CustomUser.objects.get(id=teacher_id)
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)
            courses = Course.objects.filter(id__in=course_ids)

            existing_assignment = CourseTeacher.objects.filter(
                user=teacher,
                department=department,
                program=program,
                semester=semester
            ).first()

            if existing_assignment:
                existing_courses = set(existing_assignment.course.all())
                new_courses = set(courses)
                existing_assignment.course.add(*new_courses)
                new_courses_added = len(new_courses - existing_courses)
                if new_courses_added > 0:
                    # Create notification for new courses
                    for course in (new_courses - existing_courses):
                        Notification.objects.create(
                            user=teacher,
                            message=f"You have been allotted the course: {course.name} ({course.code})"
                        )
                    messages.success(request, f"Added {new_courses_added} new course(s) to existing assignment!")
                else:
                    messages.info(request, "No new courses to add - teacher already assigned to selected courses.")
            else:
                course_teacher = CourseTeacher.objects.create(
                    user=teacher,
                    department=department,
                    program=program,
                    semester=semester
                )
                course_teacher.course.set(courses)
                # Create notification for all assigned courses
                for course in courses:
                    Notification.objects.create(
                        user=teacher,
                        message=f"You have been allotted the course: {course.name} ({course.code})"
                    )
                messages.success(request, "Teacher assigned to courses successfully!")

            return redirect('assign_teacher')

        except CustomUser.DoesNotExist:
            messages.error(request, "Teacher not found")
            return redirect('assign_teacher')
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect('assign_teacher')

    # GET request - show form
    departments = Department.objects.all()
    course_assignments = CourseTeacher.objects.select_related(
        'user', 'department', 'program', 'semester'
    ).prefetch_related('course').order_by('user', 'program', 'semester')

    return render(request, 'attendance/assign_teacher.html', {
        'departments': departments,
        'course_assignments': course_assignments
    })

@login_required
def get_teachers_by_department(request, department_id=None):
    try:
        # Get department_id from URL parameter or GET request
        dept_id = department_id or request.GET.get('department_id')
        if not dept_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)

        print(f"Fetching teachers for department ID: {dept_id}") # Debug log
        
        # Get all teachers from the specified department who are not already chairpersons
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=dept_id
        ).exclude(
            chairperson__isnull=False  # Exclude teachers who are already chairpersons
        ).select_related('teacher').values('id', 'first_name', 'last_name', 'email')
        
        print(f"Found {teachers.count()} teachers") # Debug log
        
        # Format teacher names
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data}, safe=False)
    except CustomUser.DoesNotExist:
        print("No teachers found for this department") # Debug log
        return JsonResponse({'error': 'No teachers found for this department'}, status=404)
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get programs for the department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        # Convert to list and return
        programs_list = list(programs)
        print(f"Returning data: {programs_list}") # Debug log
        
        return JsonResponse({
            'status': 'success',
            'programs': programs_list
        })
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        }, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_courses(request):
    try:
        semester_id = request.GET.get('semester_id')
        program_id = request.GET.get('program_id')
        department_id = request.GET.get('department_id')
        
        if not all([semester_id, program_id, department_id]):
            return JsonResponse({'error': 'All parameters are required'}, status=400)
        
        # Get courses based on all three parameters
        courses = Course.objects.filter(
            semester_id=semester_id,
            program_id=program_id,
            department_id=department_id
        ).values('id', 'name', 'code')
        
        # Format the response
        courses_data = [{
            'id': course['id'],
            'name': f"{course['code']} - {course['name']}"
        } for course in courses]
        
        return JsonResponse({'courses': courses_data})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_teachers_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching teachers for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get all teachers from the department who have associated CustomUser accounts
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=department_id
        ).select_related('teacher').values(
            'id',
            'first_name',
            'last_name',
            'email',
            'teacher__teacher_code'
        ).order_by('first_name', 'last_name')
        
        print(f"Found {teachers.count()} teachers in department") # Debug log
        
        # Format teacher data
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'teacher_code': teacher['teacher__teacher_code'],
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data})
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        programs_data = list(programs)
        print(f"Returning data: {programs_data}") # Debug log
        
        return JsonResponse({'programs': programs_data})
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        print(f"Fetching semesters for program ID: {program_id}") # Debug log
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {semesters.count()} semesters") # Debug log
        
        semesters_data = list(semesters)
        return JsonResponse({'semesters': semesters_data}, safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

from django.http import JsonResponse
from .models import Program

def load_programs(request):
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)



from django.http import JsonResponse
from .models import Semester

def load_semesters(request):
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)




from django.http import JsonResponse
from .models import Course

def load_courses(request):
    semester_id = request.GET.get("semester_id")
    program_id = request.GET.get("program_id")
    department_id = request.GET.get("department_id")
    
    try:
        # Start with base query
        courses = Course.objects.all()
        
        # Apply filters if provided
        if semester_id:
            courses = courses.filter(semester_id=semester_id)
        if program_id:
            courses = courses.filter(program_id=program_id)
        if department_id:
            courses = courses.filter(department_id=department_id)
        
        # Get required fields
        courses = courses.values("id", "name", "code")
        
        return JsonResponse(list(courses), safe=False)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)





from django.shortcuts import render
from .models import CourseTeacher

@login_required
def teacher_dashboard(request):
    if request.user.role not in ['faculty', 'chairperson']:
        messages.error(request, "You are not authorized to access this page.")
        return redirect('home')
    
    try:
        # Get teacher's course assignments
        course_assignments = CourseTeacher.objects.filter(
            user=request.user
        ).select_related(
            'department', 'program', 'semester'
        ).prefetch_related('course').order_by('program', 'semester')
        
        # Calculate total number of courses
        total_courses = sum(assignment.course.count() for assignment in course_assignments)
        
        # Get all notifications for the user
        all_notifications = Notification.objects.filter(user=request.user)
        
        # Get unread count
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        
        # Get recent notifications separately
        recent_notifications = Notification.objects.filter(
            user=request.user
        ).order_by('-created_at')[:10]
        
        # Get attendance change requests for courses taught by this teacher
        assigned_courses = []
        for assignment in course_assignments:
            assigned_courses.extend(assignment.course.all())
        
        attendance_change_requests = AttendanceChangeRequest.objects.filter(
            course__in=assigned_courses,
            status='pending'
        ).select_related('student', 'course').order_by('-created_at')
        
        context = {
            'course_assignments': course_assignments,
            'total_courses': total_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count,
            'user': request.user,
            'attendance_change_requests': attendance_change_requests
        }
        
        return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', context)
        
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('unified_login')

@login_required
def view_course_students(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        date = request.POST.get('date')
        for student in enrolled_students:
            status = request.POST.get(f'status_{student.id}', 'Absent')
            Attendance.objects.create(
                course=course,
                student=student.user,
                date=date,
                status=status
            )
        messages.success(request, "Attendance marked successfully!")
        return redirect('view_course_students', course_id=course_id)

    return render(request, 'attendance/teacher_authentication_template/course_students.html', {
        'course': course,
        'enrolled_students': enrolled_students
    })

def register_admin(request):
    if request.method == 'POST':
        form = AdminRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.role = "admin"  # Set role to admin
            user.is_staff = True  # Set is_staff to True
            user.save()
            login(request, user)
            return redirect('admin_dashboard')
    else:
        form = AdminRegistrationForm()
    return render(request, 'attendance/admin_authentication_template/register_admin.html', {'form': form})

@login_required
def remove_course_assignment(request, assignment_id):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    try:
        assignment = CourseTeacher.objects.get(id=assignment_id)
        assignment.delete()
        messages.success(request, "Course assignment removed successfully!")
    except CourseTeacher.DoesNotExist:
        messages.error(request, "Course assignment not found.")
    except Exception as e:
        messages.error(request, f"Error removing assignment: {str(e)}")

    return redirect('assign_teacher')

@login_required
def export_attendance_csv(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.csv"'
    
    writer = csv.writer(response)
    
    # Write filter information
    writer.writerow(['Attendance Summary - Filter Details'])
    writer.writerow(['Course:', f'{course.name} ({course.code})'])
    writer.writerow(['Department:', course.department.name])
    writer.writerow(['Program:', course.program.name])
    writer.writerow(['Semester:', course.semester.name])
    writer.writerow([])  # Empty row for spacing
    
    if from_date or to_date or student_name or status:
        writer.writerow(['Applied Filters:'])
        if from_date and to_date:
            writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
        if student_name:
            writer.writerow(['Student:', student_name])
        if status:
            writer.writerow(['Status:', status])
        writer.writerow([])  # Empty row for spacing
    
    # Write table header
    writer.writerow(['Sr. No.', 'Student Name', 'Present', 'Classes', '%'])
    
    # Calculate attendance for each student
    for index, student in enumerate(students, 1):
        student_records = attendance_records.filter(student=student)
        # Count total classes for this student
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        # Calculate attendance percentage
        attendance_percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
        writer.writerow([index, student.name, str(present_count), str(total_classes), f'{attendance_percentage}%'])
    
    return response

@login_required
def export_attendance_pdf(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create PDF response
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    
    # Define styles
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Title'],
        fontSize=14,
        spaceAfter=12,
        alignment=1
    )
    
    # Add filter information
    elements.append(Paragraph("Attendance Summary - Filter Details", title_style))
    elements.append(Spacer(1, 12))
    
    # Add course information
    course_info = [
        f"Course: {course.name} ({course.code})",
        f"Department: {course.department.name}",
        f"Program: {course.program.name}",
        f"Semester: {course.semester.name}"
    ]
    for info in course_info:
        elements.append(Paragraph(info, styles['Normal']))
        elements.append(Spacer(1, 6))
    
    elements.append(Spacer(1, 12))
    
    # Add filter information if any filters are applied
    if from_date or to_date or student_name or status:
        elements.append(Paragraph("Applied Filters:", styles['Heading3']))
        if from_date and to_date:
            elements.append(Paragraph(f"Date Range: {from_date} to {to_date}", styles['Normal']))
        if student_name:
            elements.append(Paragraph(f"Student Name: {student_name}", styles['Normal']))
        if status:
            elements.append(Paragraph(f"Status: {status}", styles['Normal']))
    
    elements.append(Spacer(1, 12))
    
    # Add attendance table
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response





# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response




# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response


    
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response

from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response






# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response



# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


# ✅ Add Department
@login_required
def add_department(request):
    """Handles adding a new department."""
    if request.method == "POST":
        name = request.POST.get("name")
        if name:
            if Department.objects.filter(name=name).exists():
                messages.error(request, "Department already exists!")
            else:
                Department.objects.create(name=name)
                messages.success(request, "Department added successfully!")
                return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/add_department.html")


# ✅ Edit Department
@login_required
def edit_department(request, dept_id):
    """Handles editing an existing department."""
    department = get_object_or_404(Department, id=dept_id)

    if request.method == "POST":
        new_name = request.POST.get("name")
        if new_name:
            department.name = new_name
            department.save()
            messages.success(request, "Department updated successfully!")
            return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/edit_department.html", {"department": department})


# ✅ Delete Department
@login_required
def delete_department(request, dept_id):
    if not request.user.is_staff:
        messages.error(request, "Access Denied!")
        return redirect("home")

    department = get_object_or_404(Department, id=dept_id)
    department.delete()
    messages.success(request, "Department deleted successfully!")
    return redirect("manage_department")




# -----------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------ MANAGE_PROGRAM---------------------------------------------------------------#
# ✅ Manage Programs (List All)
from django.db import IntegrityError
from django.contrib import messages
from attendance.models import Program, Department, Semester

def manage_programs(request):
    departments = Department.objects.all()
    programs = Program.objects.select_related('department').all()

    if request.method == "POST":
        try:
            department_id = request.POST.get("department")
            program_name = request.POST.get("program_name")
            duration = int(request.POST.get("duration"))  # Convert to int safely
            num_semesters = int(request.POST.get("num_semesters"))  # Convert to int safely

            department = Department.objects.get(id=department_id)
            program = Program.objects.create(
                department=department, name=program_name, duration=duration, num_semesters=num_semesters
            )

            # Prevent duplicate semesters
            for i in range(1, num_semesters + 1):
                semester_name = "Semester " + str(i)  # Explicitly convert i to str
                if not Semester.objects.filter(program=program, name=semester_name).exists():
                    Semester.objects.create(program=program, name=semester_name)

            messages.success(request, "Program and semesters added successfully!")

        except IntegrityError:
            messages.error(request, "A program with the same name or semester name already exists in this department.")
        except ValueError:
            messages.error(request, "Invalid input: Duration and number of semesters must be numbers.")
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")

    return render(request, "attendance/manage_program_template/manage_programs.html", {"departments": departments, "programs": programs})



def delete_program(request, program_id):
    """Handles program deletion."""
    try:
        program = Program.objects.get(id=program_id)
        program.delete()
        messages.success(request, "Program deleted successfully!")
    except Program.DoesNotExist:
        messages.error(request, "Program not found.")

    return redirect("manage_programs")



def edit_program(request, program_id):
    program = get_object_or_404(Program, id=program_id)
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_name = request.POST.get("program_name")
        duration = request.POST.get("duration")
        num_semesters = request.POST.get("num_semesters")

        # Validate and save
        if department_id and program_name and duration and num_semesters:
            program.department_id = department_id
            program.name = program_name
            program.duration = duration
            program.num_semesters = num_semesters
            program.save()
            messages.success(request, "Program updated successfully!")
            return redirect("manage_programs")

    return render(request, "attendance/manage_program_template/edit_program.html", {"program": program, "departments": departments})



# ✅ Add Program
@login_required
def add_program(request):
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")  # Get selected department
        program_name = request.POST.get("program_name")  # Get program name

        if not department_id or not program_name:
            messages.error(request, "Please fill in all fields.")
            return render(request, "attendance/add_program.html", {"departments": departments})

        try:
            department = Department.objects.get(id=department_id)  # Fetch department
            Program.objects.create(name=program_name, department=department)  # Create new program
            messages.success(request, f"Program '{program_name}' added successfully!")
            return redirect("manage_programs")
        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")

    return render(request, "attendance/manage_program_template/add_program.html", {"departments": departments})






# ------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_SEMESTER------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Semester  # Ensure you have a Semester model
from .forms import SemesterForm  # Create a form for Semester model




# ✅ Manage Semesters (List All)

@login_required
def manage_semesters(request):
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()

    selected_department = request.GET.get('department')
    selected_program = request.GET.get('program')

    # Filter based on department and program
    if selected_department:
        programs = programs.filter(department_id=selected_department)
    if selected_program:
        semesters = semesters.filter(program_id=selected_program)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'selected_department': selected_department,
        'selected_program': selected_program,
    }
    return render(request, 'attendance/manage_semester_template/manage_semesters.html', context)



#-------------------------------------------------------------------------------------------------------------------------------------#
#-------------------------------------------------------MANAGE_COURSE-----------------------------------------------------------------#


# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

def manage_courses(request):
    """View to add, filter, and display courses."""
    departments = Department.objects.all()
    courses = Course.objects.all()

    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')

    # Get programs and semesters based on selected department
    programs = Program.objects.none()
    semesters = Semester.objects.none()

    if department_id:
        programs = Program.objects.filter(department_id=department_id)
        courses = courses.filter(department_id=department_id)
        
        if program_id:
            semesters = Semester.objects.filter(program_id=program_id)
            courses = courses.filter(program_id=program_id)
            
            if semester_id:
                courses = courses.filter(semester_id=semester_id)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'courses': courses,
        'selected_department': department_id,
        'selected_program': program_id,
        'selected_semester': semester_id
    }
    return render(request, 'attendance/manage_courses.html', context)

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

def edit_course(request, course_id):
    course = get_object_or_404(Course, id=course_id)
    departments = Department.objects.all()

    if request.method == 'POST':
        try:
            course.department_id = request.POST['department']
            course.program_id = request.POST['program']
            course.semester_id = request.POST['semester']
            course.code = request.POST['course_code']
            course.name = request.POST['course_name']
            course.credit = request.POST['course_credit']
            course.save()
            messages.success(request, f'Course "{course.name}" has been updated successfully!')
            return redirect('manage_courses')
        except Exception as e:
            messages.error(request, f'Error updating course: {str(e)}')
            return redirect('edit_course', course_id=course_id)

    context = {
        'course': course,
        'departments': departments,
    }
    return render(request, 'attendance/manage_course_template/edit_course.html', context)


def delete_course(request, course_id):
    """View to delete a course."""
    try:
        course = get_object_or_404(Course, id=course_id)
        course_name = course.name
        course.delete()
        messages.success(request, f'Course "{course_name}" has been deleted successfully!')
    except Exception as e:
        messages.error(request, f'Error deleting course: {str(e)}')
    return redirect("manage_courses")

def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)

def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)



#-------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_TEACHER-------------------------------------------------------------------#
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import Department, Teacher

def manage_teachers(request):
    departments = Department.objects.all()
    teachers = Teacher.objects.all()

    # Filtering by department
    department_id = request.GET.get('department')
    if department_id:
        teachers = teachers.filter(department_id=department_id)

    if request.method == "POST":
        teacher_code = request.POST.get('teacher_code')
        name = request.POST.get('name')
        department_id = request.POST.get('department')

        # Check if teacher_code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, "Teacher code already exists!")
        else:
            department = get_object_or_404(Department, id=department_id)
            teacher = Teacher.objects.create(teacher_code=teacher_code, name=name, department=department)
            messages.success(request, f"Teacher {teacher.name} (Code: {teacher.teacher_code}) added successfully!")
            return redirect('manage_teachers')

    return render(request, "attendance/manage_teacher_template/manage_teachers.html", {"departments": departments, "teachers": teachers})


def edit_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    departments = Department.objects.all()

    if request.method == "POST":
        teacher.teacher_code = request.POST.get("teacher_code")
        teacher.name = request.POST.get("name")
        department_id = request.POST.get("department")
        teacher.department = get_object_or_404(Department, id=department_id)
        teacher.save()
        messages.success(request, "Teacher details updated successfully!")
        return redirect("manage_teachers")

    return render(request, "attendance/manage_teacher_template/edit_teacher.html", {"teacher": teacher, "departments": departments})


def delete_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    teacher.delete()
    messages.success(request, "Teacher deleted successfully!")
    return redirect("manage_teachers")

#--------------------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------MANAGE_STUDENT-------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import JsonResponse
from .models import Student, Department, Program, Semester

def manage_students(request):
    """View to add, filter, and display students."""
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()
    students = Student.objects.all()

    # Handling student filtering logic
    department_filter = request.GET.get("department")
    program_filter = request.GET.get("program")
    semester_filter = request.GET.get("semester")

    if department_filter:
        students = students.filter(department_id=department_filter)
        programs = Program.objects.filter(department_id=department_filter)  # Fetch relevant programs

    if program_filter:
        students = students.filter(program_id=program_filter)
        semesters = Semester.objects.filter(program_id=program_filter)  # Fetch relevant semesters

    if semester_filter:
        students = students.filter(semester_id=semester_filter)

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_id = request.POST.get("program")
        semester_id = request.POST.get("semester")
        enrollment_no = request.POST.get("enrollment_no").strip()
        roll_no = request.POST.get("roll_no").strip()
        session = request.POST.get("session").strip()
        student_name = request.POST.get("student_name").strip()

        if not (department_id and program_id and semester_id and enrollment_no and roll_no and session and student_name):
            messages.error(request, "All fields are required.")
            return redirect("manage_students")

        department = get_object_or_404(Department, id=department_id)
        program = get_object_or_404(Program, id=program_id, department=department)  # Ensure program belongs to department
        semester = get_object_or_404(Semester, id=semester_id, program=program)  # Ensure semester belongs to program

        if Student.objects.filter(enrollment_no=enrollment_no).exists():
            messages.error(request, "Student with this enrollment number already exists.")
        else:
            student = Student.objects.create(
                department=department,
                program=program,
                semester=semester,
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                session=session,
                name=student_name,
            )
            messages.success(request, f"Student {student.name} (Enrollment No: {student.enrollment_no}) added successfully.")

        return redirect("manage_students")

    context = {
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
        "students": students,
        "selected_department": department_filter,
        "selected_program": program_filter,
        "selected_semester": semester_filter,
    }
    return render(request, "attendance/manage_student_template/manage_students.html", context)


def edit_student(request, student_id):
    """View to edit an existing student."""
    student = get_object_or_404(Student, id=student_id)
    departments = Department.objects.all()
    programs = Program.objects.filter(department=student.department)
    semesters = Semester.objects.filter(program=student.program)

    if request.method == "POST":
        student.department_id = request.POST["department"]
        student.program_id = request.POST["program"]
        student.semester_id = request.POST["semester"]
        student.enrollment_no = request.POST["enrollment_no"]
        student.roll_no = request.POST["roll_no"]
        student.session = request.POST["session"]
        student.name = request.POST["student_name"]
        student.save()
        messages.success(request, "Student updated successfully!")
        return redirect("manage_students")

    context = {
        "student": student,
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
    }
    return render(request, "attendance/manage_student_template/edit_student.html", context)

def delete_student(request, student_id):
    """View to delete a student."""
    student = get_object_or_404(Student, id=student_id)
    student.delete()
    messages.success(request, "Student deleted successfully.")
    return redirect("manage_students")


# AJAX Views for Dynamic Dropdowns
def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)


def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)


def get_programs_by_department(request, department_id):
    try:
        department = Department.objects.get(id=department_id)
        programs = Program.objects.filter(department=department)
        data = [{'id': program.id, 'name': program.name} for program in programs]
        return JsonResponse(data, safe=False)
    except Department.DoesNotExist:
        return JsonResponse([], safe=False)

def get_semesters_by_program(request, program_id=None):
    try:
        # Try to get program_id from query parameters if not in URL
        if program_id is None:
            program_id = request.GET.get('program_id')
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)







#-------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------ASSIGN_TEACHER------------------------------------------------------#

# ✅ Assign Teacher to Course (Admin Only)

from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from .forms import AssignTeacherForm
from .models import CourseTeacher














from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from .forms import AssignTeacherForm
from .models import CourseTeacher, Course, Program, Semester

@login_required
def mark_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        # Get current date and time in IST
        current_datetime = timezone.localtime(timezone.now())
        current_date = current_datetime.date()
        total_students = enrolled_students.count()
        present_count = 0
        absent_count = 0

        # Process attendance for each student
        for student in enrolled_students:
            # Default status is 'Absent', only change if explicitly marked as 'Present'
            status = request.POST.get(f'status_{student.id}', 'Absent')
            try:
                # Create or get Student instance
                student_instance, created = Student.objects.get_or_create(
                    name=student.user.get_full_name(),
                    department=course_teacher.department,
                    program=course_teacher.program,
                    semester=course_teacher.semester,
                    defaults={
                        'enrollment_no': student.user.username,
                        'roll_no': student.user.username
                    }
                )
                
                # Create attendance record with current date and time
                Attendance.objects.create(
                    course=course,
                    student=student_instance,
                    date=current_date,
                    status=status,
                    marked_at=current_datetime
                )
                if status == 'Present':
                    present_count += 1
                else:
                    absent_count += 1

                # --- Notification Logic ---
                # Calculate attendance percentage for this student in this course
                total_classes = Attendance.objects.filter(course=course, student=student_instance).count()
                present_classes = Attendance.objects.filter(course=course, student=student_instance, status='Present').count()
                attendance_percentage = (present_classes / total_classes) * 100 if total_classes > 0 else 0
                from attendance.models import Notification
                if attendance_percentage < 75:
                    message = f"You are requested to attend the classes of {course.name} because your attendance in this course is {attendance_percentage:.2f}%, which is lower than the 75% criteria."
                    Notification.objects.create(
                        user=student.user,
                        title=f"Low Attendance in {course.code}",
                        message=message,
                        notification_type='general',
                        is_read=False
                    )
            except Exception as e:
                messages.error(request, f"Error saving attendance for {student.user.get_full_name()}: {str(e)}")
                return redirect('mark_attendance', course_id=course_id)

        messages.success(request, f"Attendance marked successfully! Present: {present_count}, Absent: {absent_count}")
        return redirect('view_attendance', course_id=course_id)

    # Get current time in IST
    current_time = timezone.localtime(timezone.now())
    
    return render(request, 'attendance/teacher_authentication_template/mark_attendance.html', {
        'course': course,
        'enrolled_students': enrolled_students,
        'current_datetime': current_time
    })




# ------------------------------------------------------------------------------

import csv
from django.http import HttpResponse
from .models import Attendance

@login_required
def export_attendance(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="attendance.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Student', 'Course', 'Status', 'Date'])

    for record in Attendance.objects.all():
        writer.writerow([record.student.name, record.course.name, record.status, record.date])

    return response



# ----------------------------------------------------------------------------------

from django.http import JsonResponse
from .models import Semester, Program

def get_semesters(request):
    """Returns semesters based on selected program (for dynamic dropdown)."""
    program_id = request.GET.get("program_id")
    
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
        return JsonResponse(list(semesters), safe=False)
    
    return JsonResponse({"error": "Invalid Request"}, status=400)




# -----------------------------------------------------------------------------------
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages



from .forms import EnrollmentForm

def enroll_students(request):
    if request.method == "POST":
        form = EnrollmentForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('enroll_students')
    else:
        form = EnrollmentForm()
    return render(request, 'attendance/enroll_students.html', {'form': form})




from .models import Attendance

@login_required
def view_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Order by date descending and then by time descending
    attendance_records = attendance_records.order_by('-date', '-marked_at')

    # Calculate attendance statistics for each student
    attendance_summary = {}
    
    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()
    
    for student in students:
        # Get all attendance records for this student after filtering
        student_records = attendance_records.filter(student=student)
        
        # Count total classes for this student (unique date+marked_at combinations)
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        
        # Calculate attendance percentage
        percentage = round((present_count / total_classes * 100), 2) if total_classes > 0 else 0
        
        attendance_summary[student.id] = {
            'name': student.name,
            'present_count': present_count,
            'total_classes': total_classes,
            'percentage': percentage
        }

    # Get unique dates for the date filter dropdown
    unique_dates = attendance_records.values_list('date', flat=True).distinct().order_by('-date')
    
    # Get unique student names for the student filter dropdown
    unique_students = students.values_list('name', flat=True).order_by('name')

    return render(request, 'attendance/teacher_authentication_template/view_attendance.html', {
        'course': course,
        'attendance_records': attendance_records,
        'attendance_summary': attendance_summary,
        'unique_dates': unique_dates,
        'unique_students': unique_students,
        'selected_from_date': from_date,
        'selected_to_date': to_date,
        'selected_student': student_name,
        'selected_status': status
    })



def generate_reports(request):
    return render(request, 'attendance/generate_reports.html')




from django.shortcuts import render
from django.contrib.auth.decorators import login_required





# -----------------------------------------------------------------------------------------------------------------------

from django.shortcuts import render, redirect
from django.http import JsonResponse
from .models import CourseTeacher, Program, Semester, Course
from .forms import AssignTeacherForm

from django.shortcuts import render, redirect
from .forms import AssignTeacherForm
from .models import CourseTeacher

@login_required
def assign_teacher(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    if request.method == "POST":
        try:
            teacher_id = request.POST.get('teacher')
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_ids = request.POST.getlist('courses')

            if not all([teacher_id, department_id, program_id, semester_id, course_ids]):
                messages.error(request, "All fields are required.")
                return redirect('assign_teacher')

            teacher = CustomUser.objects.get(id=teacher_id)
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)
            courses = Course.objects.filter(id__in=course_ids)

            existing_assignment = CourseTeacher.objects.filter(
                user=teacher,
                department=department,
                program=program,
                semester=semester
            ).first()

            if existing_assignment:
                existing_courses = set(existing_assignment.course.all())
                new_courses = set(courses)
                existing_assignment.course.add(*new_courses)
                new_courses_added = len(new_courses - existing_courses)
                if new_courses_added > 0:
                    # Create notification for new courses
                    for course in (new_courses - existing_courses):
                        Notification.objects.create(
                            user=teacher,
                            message=f"You have been allotted the course: {course.name} ({course.code})"
                        )
                    messages.success(request, f"Added {new_courses_added} new course(s) to existing assignment!")
                else:
                    messages.info(request, "No new courses to add - teacher already assigned to selected courses.")
            else:
                course_teacher = CourseTeacher.objects.create(
                    user=teacher,
                    department=department,
                    program=program,
                    semester=semester
                )
                course_teacher.course.set(courses)
                # Create notification for all assigned courses
                for course in courses:
                    Notification.objects.create(
                        user=teacher,
                        message=f"You have been allotted the course: {course.name} ({course.code})"
                    )
                messages.success(request, "Teacher assigned to courses successfully!")

            return redirect('assign_teacher')

        except CustomUser.DoesNotExist:
            messages.error(request, "Teacher not found")
            return redirect('assign_teacher')
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect('assign_teacher')

    # GET request - show form
    departments = Department.objects.all()
    course_assignments = CourseTeacher.objects.select_related(
        'user', 'department', 'program', 'semester'
    ).prefetch_related('course').order_by('user', 'program', 'semester')

    return render(request, 'attendance/assign_teacher.html', {
        'departments': departments,
        'course_assignments': course_assignments
    })

@login_required
def get_teachers_by_department(request, department_id=None):
    try:
        # Get department_id from URL parameter or GET request
        dept_id = department_id or request.GET.get('department_id')
        if not dept_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)

        print(f"Fetching teachers for department ID: {dept_id}") # Debug log
        
        # Get all teachers from the specified department who are not already chairpersons
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=dept_id
        ).exclude(
            chairperson__isnull=False  # Exclude teachers who are already chairpersons
        ).select_related('teacher').values('id', 'first_name', 'last_name', 'email')
        
        print(f"Found {teachers.count()} teachers") # Debug log
        
        # Format teacher names
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data}, safe=False)
    except CustomUser.DoesNotExist:
        print("No teachers found for this department") # Debug log
        return JsonResponse({'error': 'No teachers found for this department'}, status=404)
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get programs for the department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        # Convert to list and return
        programs_list = list(programs)
        print(f"Returning data: {programs_list}") # Debug log
        
        return JsonResponse({
            'status': 'success',
            'programs': programs_list
        })
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        }, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_courses(request):
    try:
        semester_id = request.GET.get('semester_id')
        program_id = request.GET.get('program_id')
        department_id = request.GET.get('department_id')
        
        if not all([semester_id, program_id, department_id]):
            return JsonResponse({'error': 'All parameters are required'}, status=400)
        
        # Get courses based on all three parameters
        courses = Course.objects.filter(
            semester_id=semester_id,
            program_id=program_id,
            department_id=department_id
        ).values('id', 'name', 'code')
        
        # Format the response
        courses_data = [{
            'id': course['id'],
            'name': f"{course['code']} - {course['name']}"
        } for course in courses]
        
        return JsonResponse({'courses': courses_data})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_teachers_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching teachers for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get all teachers from the department who have associated CustomUser accounts
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=department_id
        ).select_related('teacher').values(
            'id',
            'first_name',
            'last_name',
            'email',
            'teacher__teacher_code'
        ).order_by('first_name', 'last_name')
        
        print(f"Found {teachers.count()} teachers in department") # Debug log
        
        # Format teacher data
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'teacher_code': teacher['teacher__teacher_code'],
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data})
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        programs_data = list(programs)
        print(f"Returning data: {programs_data}") # Debug log
        
        return JsonResponse({'programs': programs_data})
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        print(f"Fetching semesters for program ID: {program_id}") # Debug log
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {semesters.count()} semesters") # Debug log
        
        semesters_data = list(semesters)
        return JsonResponse({'semesters': semesters_data}, safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

from django.http import JsonResponse
from .models import Program

def load_programs(request):
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)



from django.http import JsonResponse
from .models import Semester

def load_semesters(request):
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)




from django.http import JsonResponse
from .models import Course

def load_courses(request):
    semester_id = request.GET.get("semester_id")
    program_id = request.GET.get("program_id")
    department_id = request.GET.get("department_id")
    
    try:
        # Start with base query
        courses = Course.objects.all()
        
        # Apply filters if provided
        if semester_id:
            courses = courses.filter(semester_id=semester_id)
        if program_id:
            courses = courses.filter(program_id=program_id)
        if department_id:
            courses = courses.filter(department_id=department_id)
        
        # Get required fields
        courses = courses.values("id", "name", "code")
        
        return JsonResponse(list(courses), safe=False)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)





from django.shortcuts import render
from .models import CourseTeacher

@login_required
def teacher_dashboard(request):
    if request.user.role not in ['faculty', 'chairperson']:
        messages.error(request, "You are not authorized to access this page.")
        return redirect('home')
    
    try:
        # Get teacher's course assignments
        course_assignments = CourseTeacher.objects.filter(
            user=request.user
        ).select_related(
            'department', 'program', 'semester'
        ).prefetch_related('course').order_by('program', 'semester')
        
        # Calculate total number of courses
        total_courses = sum(assignment.course.count() for assignment in course_assignments)
        
        # Get all notifications for the user
        all_notifications = Notification.objects.filter(user=request.user)
        
        # Get unread count
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        
        # Get recent notifications separately
        recent_notifications = Notification.objects.filter(
            user=request.user
        ).order_by('-created_at')[:10]
        
        # Get attendance change requests for courses taught by this teacher
        assigned_courses = []
        for assignment in course_assignments:
            assigned_courses.extend(assignment.course.all())
        
        attendance_change_requests = AttendanceChangeRequest.objects.filter(
            course__in=assigned_courses,
            status='pending'
        ).select_related('student', 'course').order_by('-created_at')
        
        context = {
            'course_assignments': course_assignments,
            'total_courses': total_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count,
            'user': request.user,
            'attendance_change_requests': attendance_change_requests
        }
        
        return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', context)
        
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('unified_login')

@login_required
def view_course_students(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        date = request.POST.get('date')
        for student in enrolled_students:
            status = request.POST.get(f'status_{student.id}', 'Absent')
            Attendance.objects.create(
                course=course,
                student=student.user,
                date=date,
                status=status
            )
        messages.success(request, "Attendance marked successfully!")
        return redirect('view_course_students', course_id=course_id)

    return render(request, 'attendance/teacher_authentication_template/course_students.html', {
        'course': course,
        'enrolled_students': enrolled_students
    })

def register_admin(request):
    if request.method == 'POST':
        form = AdminRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.role = "admin"  # Set role to admin
            user.is_staff = True  # Set is_staff to True
            user.save()
            login(request, user)
            return redirect('admin_dashboard')
    else:
        form = AdminRegistrationForm()
    return render(request, 'attendance/admin_authentication_template/register_admin.html', {'form': form})

@login_required
def remove_course_assignment(request, assignment_id):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    try:
        assignment = CourseTeacher.objects.get(id=assignment_id)
        assignment.delete()
        messages.success(request, "Course assignment removed successfully!")
    except CourseTeacher.DoesNotExist:
        messages.error(request, "Course assignment not found.")
    except Exception as e:
        messages.error(request, f"Error removing assignment: {str(e)}")

    return redirect('assign_teacher')

@login_required
def export_attendance_csv(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.csv"'
    
    writer = csv.writer(response)
    
    # Write filter information
    writer.writerow(['Attendance Summary - Filter Details'])
    writer.writerow(['Course:', f'{course.name} ({course.code})'])
    writer.writerow(['Department:', course.department.name])
    writer.writerow(['Program:', course.program.name])
    writer.writerow(['Semester:', course.semester.name])
    writer.writerow([])  # Empty row for spacing
    
    if from_date or to_date or student_name or status:
        writer.writerow(['Applied Filters:'])
        if from_date and to_date:
            writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
        if student_name:
            writer.writerow(['Student:', student_name])
        if status:
            writer.writerow(['Status:', status])
        writer.writerow([])  # Empty row for spacing
    
    # Write table header
    writer.writerow(['Sr. No.', 'Student Name', 'Present', 'Classes', '%'])
    
    # Calculate attendance for each student
    for index, student in enumerate(students, 1):
        student_records = attendance_records.filter(student=student)
        # Count total classes for this student
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        # Calculate attendance percentage
        attendance_percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
        writer.writerow([index, student.name, str(present_count), str(total_classes), f'{attendance_percentage}%'])
    
    return response

@login_required
def export_attendance_pdf(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create PDF response
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    
    # Define styles
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Title'],
        fontSize=14,
        spaceAfter=12,
        alignment=1
    )
    
    # Add filter information
    elements.append(Paragraph("Attendance Summary - Filter Details", title_style))
    elements.append(Spacer(1, 12))
    
    # Add course information
    course_info = [
        f"Course: {course.name} ({course.code})",
        f"Department: {course.department.name}",
        f"Program: {course.program.name}",
        f"Semester: {course.semester.name}"
    ]
    for info in course_info:
        elements.append(Paragraph(info, styles['Normal']))
        elements.append(Spacer(1, 6))
    
    elements.append(Spacer(1, 12))
    
    # Add filter information if any filters are applied
    if from_date or to_date or student_name or status:
        elements.append(Paragraph("Applied Filters:", styles['Heading3']))
        if from_date and to_date:
            elements.append(Paragraph(f"Date Range: {from_date} to {to_date}", styles['Normal']))
from attendance.models import CustomUser, Course
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout, get_user_model, update_session_auth_hash
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json
from django.utils import timezone
from django.template.loader import get_template, render_to_string
from xhtml2pdf import pisa
import csv
from io import StringIO, BytesIO
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from .models import Department, Program, Semester, Course, Student, Attendance
from .dean_views import dean_attendance_summary, dean_export_attendance_csv, dean_export_attendance_pdf



# Import models
from .models import (
    CustomUser,
    Course,
    Program,
    Semester,
    Attendance,
    Student,
    Teacher,
    Department,
    Enrollment,
    EnrollStudent,
    Chairperson,
    CourseTeacher,
    Notification,
    AttendanceChangeRequest,
    Dean,
    ChairpersonRequest,
    Controller

)

# Import forms
from .forms import (
    TeacherRegistrationForm,
    CustomUserCreationForm,
    CourseForm,
    AttendanceForm,
    StudentRegisterForm,
    AdminRegistrationForm,
    ChairpersonRegistrationForm,
    AttendanceChangeRequestForm
)


# Utilities
import csv
import datetime
from django.db.models import Count, Q
from django.core.paginator import Paginator
from django.template.loader import render_to_string
from django.utils.decorators import method_decorator
import random
import string

# Define User model correctly (if CustomUser is set in settings.py)
User = get_user_model()


# Home Page
def home(request):
    return render(request, 'attendance/fundamental_template/home.html')

def about(request):
    return render(request, 'attendance/about.html')

def contact(request):
    return render(request, 'attendance/contact.html')

@login_required
def profile(request):
    user = request.user
    # Update role display mapping to include chairperson
    role_display = {
        "student": "Student",
        "faculty": "Faculty",
        "admin": "Admin",
        "chairperson": "Chairperson",
        "controller": "Controller"
    }.get(user.role, "Unknown")
    
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('profile')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('profile')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('profile')
        
        try:
            # Set new password
            user.set_password(new_password1)
            user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, user)
            
            messages.success(request, 'Your password was successfully updated!')
            
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
    
    return render(request, 'attendance/fundamental_template/profile.html', {
        'user': user,
        'role_display': role_display
    })

# Logout
def logout_view(request):
    logout(request)
    return redirect('home')



# Teacher_Authentication and Dashboard----------------------------------------------------------------------------------------------#


def register_teacher(request):
    if request.method == 'POST':
        # Get form data
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        department_id = request.POST.get('department')
        teacher_code = request.POST.get('teacher_code')

        # Validate passwords match
        if password != confirm_password:
            messages.error(request, 'Passwords do not match!')
            return redirect('register_teacher')

        # Check if user already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, 'Email already registered!')
            return redirect('register_teacher')

        # Check if teacher code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, 'Teacher code already registered!')
            return redirect('register_teacher')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='faculty'
            )

            # Get department
            department = Department.objects.get(id=department_id)

            # Create teacher profile
            teacher = Teacher.objects.create(
                user=user,
                teacher_code=teacher_code,
                name=f"{first_name} {last_name}",
                department=department
            )

            messages.success(request, 'Registration successful! Please login with your email.')
            return redirect('unified_login')

        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            return redirect('register_teacher')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/teacher_register.html', {
        'departments': departments
    })

# Teacher Login
def teacher_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        try:
            # First try to find the user by email
            try:
                user = CustomUser.objects.get(email=username)
                username = user.username  # Use the username for authentication
            except CustomUser.DoesNotExist:
                # If not found by email, use the username as is
                pass
            
            # Authenticate with username
            user = authenticate(request, username=username, password=password)
            
            if user is not None and user.role in ['faculty', 'chairperson']:
                login(request, user)
                
                # Check if user is also a chairperson
                if Chairperson.objects.filter(user=user, is_approved=True).exists():
                    chairperson = Chairperson.objects.get(user=user)
                    request.session['is_chairperson'] = True
                    request.session['chairperson_department'] = chairperson.department.name
                
                messages.success(request, f"Welcome back, {user.get_full_name()}!")
                return redirect('teacher_dashboard')
            else:
                messages.error(request, "Invalid credentials or unauthorized access.")
        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
    
    return render(request, 'attendance/teacher_authentication_template/teacher_login.html')


# ✅ Teacher Dashboard View

from django.shortcuts import render
from .models import CourseTeacher



from django.shortcuts import render
from .models import CourseTeacher, Course

# def teacher_dashboard(request):
#     teacher = request.user  # Get logged-in teacher
#     user_name = teacher.username  # Get username

#     # Fetch assigned courses for this teacher
#     assigned_courses = CourseTeacher.objects.filter(user=teacher).select_related('department', 'semester').prefetch_related('course')

#     # Create a structured list for the template
#     response_data = []
#     for course_teacher in assigned_courses:
#         department_name = course_teacher.department.name if course_teacher.department else "N/A"
#         semester_name = course_teacher.semester.name if course_teacher.semester else "N/A"

#         for course in course_teacher.course.all():  # Iterate over ManyToManyField courses
#             response_data.append({
#                 "department": department_name,
#                 "course": course.name,  # Course name
#                 "semester": semester_name
#             })

#     return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', {
#         'response_data': response_data,
#         'user_name': user_name
#     })





# Student_Authentication and Dashboard------------------------------------------------------------------------------------------------#

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, authenticate, logout
from django.contrib import messages
from .forms import StudentRegisterForm, StudentEnrollForm
from .models import EnrollStudent, Course

from django.shortcuts import render
from .models import Department

# def student_dashboard(request):
#     departments = Department.objects.all()
#     return render(request, "attendance/student_authentication_template/student_dashboard.html", {"departments": departments})

# Student Registration
def student_register(request):
    if request.method == 'POST':
        try:
            # Get form data
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            enrollment_no = request.POST.get('enrollment_no')
            roll_no = request.POST.get('roll_no')
            first_name = request.POST.get('first_name')
            last_name = request.POST.get('last_name')
            email = request.POST.get('email')
            password = request.POST.get('password')
            session = request.POST.get('session')

            # Validate required fields
            if not all([department_id, program_id, semester_id, enrollment_no, roll_no, first_name, last_name, email, password, session]):
                messages.error(request, "All fields are required.")
                return redirect('student_register')

            # Get related objects
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)

            # Check if enrollment number already exists
            if Student.objects.filter(enrollment_no=enrollment_no).exists():
                messages.error(request, "Enrollment number already exists!")
                return redirect('student_register')

            # Check if email already exists
            if CustomUser.objects.filter(email=email).exists():
                messages.error(request, "Email already exists!")
                return redirect('student_register')

            # Create user
            user = CustomUser.objects.create_user(
                username=enrollment_no,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                role='student'
            )

            # Create student with full name
            student = Student.objects.create(
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                name=f"{first_name} {last_name}",  # Set the full name
                department=department,
                program=program,
                semester=semester,
                session=session
            )

            # Create enrollment
            enrollment = EnrollStudent.objects.create(
                user=user,
                department=department,
                program=program,
                semester=semester
            )

            messages.success(request, 'Registration successful! Please login with your enrollment number or email.')
            return redirect('unified_login')

        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist.")
        except Semester.DoesNotExist:
            messages.error(request, "Selected semester does not exist.")
        except Exception as e:
            messages.error(request, f'Registration failed: {str(e)}')
            # Delete user if student creation fails
            if 'user' in locals():
                user.delete()
        return redirect('student_register')

    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/student_register.html', {
        'departments': departments
    })

def get_programs_by_department(request, department_id):
    try:
        # Get all programs for the selected department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {len(programs)} programs for department {department_id}")  # Debug log
        return JsonResponse(list(programs), safe=False)
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request, program_id):
    try:
        # Get all semesters for the selected program
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {len(semesters)} semesters for program {program_id}")  # Debug log
        return JsonResponse(list(semesters), safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Debug log
        return JsonResponse({'error': str(e)}, status=400)

# Student Login
def student_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or enrollment number
        password = request.POST.get('password')
        
        # Try to find user by email or enrollment number
        try:
            user = CustomUser.objects.get(Q(email=username) | Q(username=username))
            user = authenticate(request, username=user.username, password=password)
        
            if user is not None and user.role == 'student':
                    login(request, user)
                    return redirect('student_dashboard')
            else:
                messages.error(request, "Invalid credentials or you are not registered as a student.")
        except CustomUser.DoesNotExist:
            messages.error(request, "Invalid credentials.")
    
    return render(request, 'attendance/student_authentication_template/student_login.html')



# Student Logout
def student_logout(request):
    logout(request)
    return redirect("student_login")

import pdfkit

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.template.loader import render_to_string
import pdfkit  # Ensure wkhtmltopdf is installed
from .models import Department, Program, Semester, Course, EnrollStudent

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from datetime import datetime
import os

@login_required
def download_enrollment_card(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()
    except EnrollStudent.DoesNotExist:
        messages.error(request, "No enrollment data found.")
        return redirect('student_dashboard')

    # Create PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="enrollment_card_{student.username}.pdf"'

    # Create the PDF object with margins
    doc = SimpleDocTemplate(
        response,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    elements = []

    # Define styles
    styles = getSampleStyleSheet()
    
    # Title style
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1,  # Center alignment
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Subtitle style
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        alignment=1,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )
    
    # Header style
    header_style = ParagraphStyle(
        'CustomHeader',
        parent=styles['Heading2'],
        fontSize=12,
        spaceAfter=10,
        textColor=colors.HexColor('#2C3E50'),
        fontName='Helvetica-Bold'
    )
    
    # Normal text style
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=5,
        textColor=colors.HexColor('#34495E'),
        fontName='Helvetica'
    )

    # Add header with logo and title
    elements.append(Paragraph("UNIVERSITY ENROLLMENT CARD", title_style))
    elements.append(Paragraph("Academic Year 2024-2025", subtitle_style))
    elements.append(Spacer(1, 20))

    # Student Information Section
    elements.append(Paragraph("STUDENT INFORMATION", header_style))
    elements.append(Spacer(1, 10))

    # Student info table
    student_data = [
        ["Student ID:", student.username],
        ["Full Name:", f"{student.first_name} {student.last_name}"],
        ["Email:", student.email],
        ["Department:", student_enrollment.department.name],
        ["Program:", student_enrollment.program.name],
        ["Semester:", student_enrollment.semester.name],
        ["Date of Issue:", datetime.now().strftime("%d %B, %Y")]
    ]
    
    student_table = Table(student_data, colWidths=[2*inch, 4*inch])
    student_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
    ]))
    elements.append(student_table)
    elements.append(Spacer(1, 20))

    # Enrolled Courses Section
    elements.append(Paragraph("ENROLLED COURSES", header_style))
    elements.append(Spacer(1, 10))

    # Course table
    course_data = [["Course Code", "Course Name", "Credit Hours"]]
    for course in enrolled_courses:
        course_data.append([course.code, course.name, str(course.credit)])
    
    course_table = Table(course_data, colWidths=[1.5*inch, 3*inch, 1.5*inch])
    course_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#BDC3C7')),
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#ECF0F1')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#2C3E50')),
    ]))
    elements.append(course_table)
    elements.append(Spacer(1, 30))

    # Footer
    footer_text = """
    <para align=center>
    <font name="Helvetica" size=8 color=#7F8C8D>
    This is an official document issued by the University.<br/>
    For any queries, please contact the Academic Office.<br/>
    Document ID: {}-{}-{}
    </font>
    </para>
    """.format(
        student.username,
        datetime.now().strftime("%Y%m%d"),
        student_enrollment.department.name.replace(" ", "")[:4].upper()  # Use first 4 letters of department name
    )
    elements.append(Paragraph(footer_text, normal_style))

    # Build PDF
    doc.build(elements)
    return response





# Admin_Authentication and Dashboard------------------------------------------------------------------------------------------------#

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages



# Admin Login
def admin_login(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        
        # Try to get user by email
        try:
            user = CustomUser.objects.get(email=email)
            # Authenticate with username (since that's what Django's authenticate uses)
            authenticated_user = authenticate(request, username=user.username, password=password)
            
            if authenticated_user is not None:
                if authenticated_user.is_superuser or authenticated_user.role == 'admin':
                    login(request, authenticated_user)
                    messages.success(request, "Login successful!")
                    return redirect('admin_dashboard')
                else:
                    messages.error(request, "You don't have admin privileges")
            else:
                messages.error(request, "Invalid password")
        except CustomUser.DoesNotExist:
            messages.error(request, "No user found with this email")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/admin_login.html')


# ✅ Admin Dashboard View
@login_required
def admin_dashboard(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
        
    # Get counts for dashboard
    total_departments = Department.objects.count()
    total_programs = Program.objects.count()
    total_semesters = Semester.objects.count()
    total_courses = Course.objects.count()
    total_teachers = Teacher.objects.count()
    total_students = Student.objects.count()
    
    # Get pending attendance change requests
    pending_requests = AttendanceChangeRequest.objects.filter(status='pending').select_related(
        'faculty', 'student', 'course'
    ).order_by('-created_at')[:5]  # Get latest 5 pending requests
    pending_requests_count = AttendanceChangeRequest.objects.filter(status='pending').count()
    
    context = {
        'total_departments': total_departments,
        'total_programs': total_programs,
        'total_semesters': total_semesters,
        'total_courses': total_courses,
        'total_teachers': total_teachers,
        'total_students': total_students,
        'pending_requests': pending_requests,
        'pending_requests_count': pending_requests_count,
    }
    
    return render(request, 'attendance/admin_authentication_template/admin_dashboard.html', context)













# ------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------MANAGE_DEPARTMENT-----------------------------------------------------------------#


# ✅ Manage Departments (List All)
@login_required
def manage_department(request):
    if request.method == "POST":
        department_name = request.POST.get("department_name")
        
        if department_name:
            # Check if department already exists
            if Department.objects.filter(name=department_name).exists():
                messages.warning(request, "Department already exists!")
            else:
                Department.objects.create(name=department_name)
                messages.success(request, "Department added successfully!")
        
        return redirect("manage_department")  # Refresh page after form submission

    # Fetch all departments
    departments = Department.objects.all()
    return render(request, "attendance/manage_department_template/manage_department.html", {"departments": departments})


# ✅ Add Department
@login_required
def add_department(request):
    """Handles adding a new department."""
    if request.method == "POST":
        name = request.POST.get("name")
        if name:
            if Department.objects.filter(name=name).exists():
                messages.error(request, "Department already exists!")
            else:
                Department.objects.create(name=name)
                messages.success(request, "Department added successfully!")
                return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/add_department.html")


# ✅ Edit Department
@login_required
def edit_department(request, dept_id):
    """Handles editing an existing department."""
    department = get_object_or_404(Department, id=dept_id)

    if request.method == "POST":
        new_name = request.POST.get("name")
        if new_name:
            department.name = new_name
            department.save()
            messages.success(request, "Department updated successfully!")
            return redirect("manage_department")
        else:
            messages.error(request, "Department name cannot be empty.")

    return render(request, "attendance/manage_department_template/edit_department.html", {"department": department})


# ✅ Delete Department
@login_required
def delete_department(request, dept_id):
    if not request.user.is_staff:
        messages.error(request, "Access Denied!")
        return redirect("home")

    department = get_object_or_404(Department, id=dept_id)
    department.delete()
    messages.success(request, "Department deleted successfully!")
    return redirect("manage_department")




# -----------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------ MANAGE_PROGRAM---------------------------------------------------------------#
# ✅ Manage Programs (List All)
from django.db import IntegrityError
from django.contrib import messages
from attendance.models import Program, Department, Semester

def manage_programs(request):
    departments = Department.objects.all()
    programs = Program.objects.select_related('department').all()

    if request.method == "POST":
        try:
            department_id = request.POST.get("department")
            program_name = request.POST.get("program_name")
            duration = int(request.POST.get("duration"))  # Convert to int safely
            num_semesters = int(request.POST.get("num_semesters"))  # Convert to int safely

            department = Department.objects.get(id=department_id)
            program = Program.objects.create(
                department=department, name=program_name, duration=duration, num_semesters=num_semesters
            )

            # Prevent duplicate semesters
            for i in range(1, num_semesters + 1):
                semester_name = "Semester " + str(i)  # Explicitly convert i to str
                if not Semester.objects.filter(program=program, name=semester_name).exists():
                    Semester.objects.create(program=program, name=semester_name)

            messages.success(request, "Program and semesters added successfully!")

        except IntegrityError:
            messages.error(request, "A program with the same name or semester name already exists in this department.")
        except ValueError:
            messages.error(request, "Invalid input: Duration and number of semesters must be numbers.")
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")

    return render(request, "attendance/manage_program_template/manage_programs.html", {"departments": departments, "programs": programs})



def delete_program(request, program_id):
    """Handles program deletion."""
    try:
        program = Program.objects.get(id=program_id)
        program.delete()
        messages.success(request, "Program deleted successfully!")
    except Program.DoesNotExist:
        messages.error(request, "Program not found.")

    return redirect("manage_programs")



def edit_program(request, program_id):
    program = get_object_or_404(Program, id=program_id)
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_name = request.POST.get("program_name")
        duration = request.POST.get("duration")
        num_semesters = request.POST.get("num_semesters")

        # Validate and save
        if department_id and program_name and duration and num_semesters:
            program.department_id = department_id
            program.name = program_name
            program.duration = duration
            program.num_semesters = num_semesters
            program.save()
            messages.success(request, "Program updated successfully!")
            return redirect("manage_programs")

    return render(request, "attendance/manage_program_template/edit_program.html", {"program": program, "departments": departments})



# ✅ Add Program
@login_required
def add_program(request):
    departments = Department.objects.all()  # Fetch all departments

    if request.method == "POST":
        department_id = request.POST.get("department")  # Get selected department
        program_name = request.POST.get("program_name")  # Get program name

        if not department_id or not program_name:
            messages.error(request, "Please fill in all fields.")
            return render(request, "attendance/add_program.html", {"departments": departments})

        try:
            department = Department.objects.get(id=department_id)  # Fetch department
            Program.objects.create(name=program_name, department=department)  # Create new program
            messages.success(request, f"Program '{program_name}' added successfully!")
            return redirect("manage_programs")
        except Department.DoesNotExist:
            messages.error(request, "Selected department does not exist.")

    return render(request, "attendance/manage_program_template/add_program.html", {"departments": departments})






# ------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_SEMESTER------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Semester  # Ensure you have a Semester model
from .forms import SemesterForm  # Create a form for Semester model




# ✅ Manage Semesters (List All)

@login_required
def manage_semesters(request):
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()

    selected_department = request.GET.get('department')
    selected_program = request.GET.get('program')

    # Filter based on department and program
    if selected_department:
        programs = programs.filter(department_id=selected_department)
    if selected_program:
        semesters = semesters.filter(program_id=selected_program)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'selected_department': selected_department,
        'selected_program': selected_program,
    }
    return render(request, 'attendance/manage_semester_template/manage_semesters.html', context)



#-------------------------------------------------------------------------------------------------------------------------------------#
#-------------------------------------------------------MANAGE_COURSE-----------------------------------------------------------------#


# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

# Manage Courses Page

from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse
from .models import Department, Program, Semester, Course
from django.contrib import messages

def manage_courses(request):
    """View to add, filter, and display courses."""
    departments = Department.objects.all()
    courses = Course.objects.all()

    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')

    # Get programs and semesters based on selected department
    programs = Program.objects.none()
    semesters = Semester.objects.none()

    if department_id:
        programs = Program.objects.filter(department_id=department_id)
        courses = courses.filter(department_id=department_id)
        
        if program_id:
            semesters = Semester.objects.filter(program_id=program_id)
            courses = courses.filter(program_id=program_id)
            
            if semester_id:
                courses = courses.filter(semester_id=semester_id)

    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'courses': courses,
        'selected_department': department_id,
        'selected_program': program_id,
        'selected_semester': semester_id
    }
    return render(request, 'attendance/manage_courses.html', context)

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from .models import Course, Department, Program, Semester

def edit_course(request, course_id):
    course = get_object_or_404(Course, id=course_id)
    departments = Department.objects.all()

    if request.method == 'POST':
        try:
            course.department_id = request.POST['department']
            course.program_id = request.POST['program']
            course.semester_id = request.POST['semester']
            course.code = request.POST['course_code']
            course.name = request.POST['course_name']
            course.credit = request.POST['course_credit']
            course.save()
            messages.success(request, f'Course "{course.name}" has been updated successfully!')
            return redirect('manage_courses')
        except Exception as e:
            messages.error(request, f'Error updating course: {str(e)}')
            return redirect('edit_course', course_id=course_id)

    context = {
        'course': course,
        'departments': departments,
    }
    return render(request, 'attendance/manage_course_template/edit_course.html', context)


def delete_course(request, course_id):
    """View to delete a course."""
    try:
        course = get_object_or_404(Course, id=course_id)
        course_name = course.name
        course.delete()
        messages.success(request, f'Course "{course_name}" has been deleted successfully!')
    except Exception as e:
        messages.error(request, f'Error deleting course: {str(e)}')
    return redirect("manage_courses")

def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)

def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)



#-------------------------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------MANAGE_TEACHER-------------------------------------------------------------------#
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import Department, Teacher

def manage_teachers(request):
    departments = Department.objects.all()
    teachers = Teacher.objects.all()

    # Filtering by department
    department_id = request.GET.get('department')
    if department_id:
        teachers = teachers.filter(department_id=department_id)

    if request.method == "POST":
        teacher_code = request.POST.get('teacher_code')
        name = request.POST.get('name')
        department_id = request.POST.get('department')

        # Check if teacher_code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, "Teacher code already exists!")
        else:
            department = get_object_or_404(Department, id=department_id)
            teacher = Teacher.objects.create(teacher_code=teacher_code, name=name, department=department)
            messages.success(request, f"Teacher {teacher.name} (Code: {teacher.teacher_code}) added successfully!")
            return redirect('manage_teachers')

    return render(request, "attendance/manage_teacher_template/manage_teachers.html", {"departments": departments, "teachers": teachers})


def edit_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    departments = Department.objects.all()

    if request.method == "POST":
        teacher.teacher_code = request.POST.get("teacher_code")
        teacher.name = request.POST.get("name")
        department_id = request.POST.get("department")
        teacher.department = get_object_or_404(Department, id=department_id)
        teacher.save()
        messages.success(request, "Teacher details updated successfully!")
        return redirect("manage_teachers")

    return render(request, "attendance/manage_teacher_template/edit_teacher.html", {"teacher": teacher, "departments": departments})


def delete_teacher(request, teacher_id):
    teacher = get_object_or_404(Teacher, id=teacher_id)
    teacher.delete()
    messages.success(request, "Teacher deleted successfully!")
    return redirect("manage_teachers")

#--------------------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------MANAGE_STUDENT-------------------------------------------------------------------#

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import JsonResponse
from .models import Student, Department, Program, Semester

def manage_students(request):
    """View to add, filter, and display students."""
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()
    students = Student.objects.all()

    # Handling student filtering logic
    department_filter = request.GET.get("department")
    program_filter = request.GET.get("program")
    semester_filter = request.GET.get("semester")

    if department_filter:
        students = students.filter(department_id=department_filter)
        programs = Program.objects.filter(department_id=department_filter)  # Fetch relevant programs

    if program_filter:
        students = students.filter(program_id=program_filter)
        semesters = Semester.objects.filter(program_id=program_filter)  # Fetch relevant semesters

    if semester_filter:
        students = students.filter(semester_id=semester_filter)

    if request.method == "POST":
        department_id = request.POST.get("department")
        program_id = request.POST.get("program")
        semester_id = request.POST.get("semester")
        enrollment_no = request.POST.get("enrollment_no").strip()
        roll_no = request.POST.get("roll_no").strip()
        session = request.POST.get("session").strip()
        student_name = request.POST.get("student_name").strip()

        if not (department_id and program_id and semester_id and enrollment_no and roll_no and session and student_name):
            messages.error(request, "All fields are required.")
            return redirect("manage_students")

        department = get_object_or_404(Department, id=department_id)
        program = get_object_or_404(Program, id=program_id, department=department)  # Ensure program belongs to department
        semester = get_object_or_404(Semester, id=semester_id, program=program)  # Ensure semester belongs to program

        if Student.objects.filter(enrollment_no=enrollment_no).exists():
            messages.error(request, "Student with this enrollment number already exists.")
        else:
            student = Student.objects.create(
                department=department,
                program=program,
                semester=semester,
                enrollment_no=enrollment_no,
                roll_no=roll_no,
                session=session,
                name=student_name,
            )
            messages.success(request, f"Student {student.name} (Enrollment No: {student.enrollment_no}) added successfully.")

        return redirect("manage_students")

    context = {
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
        "students": students,
        "selected_department": department_filter,
        "selected_program": program_filter,
        "selected_semester": semester_filter,
    }
    return render(request, "attendance/manage_student_template/manage_students.html", context)


def edit_student(request, student_id):
    """View to edit an existing student."""
    student = get_object_or_404(Student, id=student_id)
    departments = Department.objects.all()
    programs = Program.objects.filter(department=student.department)
    semesters = Semester.objects.filter(program=student.program)

    if request.method == "POST":
        student.department_id = request.POST["department"]
        student.program_id = request.POST["program"]
        student.semester_id = request.POST["semester"]
        student.enrollment_no = request.POST["enrollment_no"]
        student.roll_no = request.POST["roll_no"]
        student.session = request.POST["session"]
        student.name = request.POST["student_name"]
        student.save()
        messages.success(request, "Student updated successfully!")
        return redirect("manage_students")

    context = {
        "student": student,
        "departments": departments,
        "programs": programs,
        "semesters": semesters,
    }
    return render(request, "attendance/manage_student_template/edit_student.html", context)

def delete_student(request, student_id):
    """View to delete a student."""
    student = get_object_or_404(Student, id=student_id)
    student.delete()
    messages.success(request, "Student deleted successfully.")
    return redirect("manage_students")


# AJAX Views for Dynamic Dropdowns
def get_programs(request):
    """AJAX view to fetch programs based on department selection."""
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)


def get_semesters(request):
    """AJAX view to fetch semesters based on program selection."""
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)


def get_programs_by_department(request, department_id):
    try:
        department = Department.objects.get(id=department_id)
        programs = Program.objects.filter(department=department)
        data = [{'id': program.id, 'name': program.name} for program in programs]
        return JsonResponse(data, safe=False)
    except Department.DoesNotExist:
        return JsonResponse([], safe=False)

def get_semesters_by_program(request, program_id=None):
    try:
        # Try to get program_id from query parameters if not in URL
        if program_id is None:
            program_id = request.GET.get('program_id')
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)







#-------------------------------------------------------------------------------------------------------------------------#
#-----------------------------------------------------ASSIGN_TEACHER------------------------------------------------------#

# ✅ Assign Teacher to Course (Admin Only)

from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from .forms import AssignTeacherForm
from .models import CourseTeacher














from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from .forms import AssignTeacherForm
from .models import CourseTeacher, Course, Program, Semester

@login_required
def mark_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        # Get current date and time in IST
        current_datetime = timezone.localtime(timezone.now())
        current_date = current_datetime.date()
        total_students = enrolled_students.count()
        present_count = 0
        absent_count = 0

        # Process attendance for each student
        for student in enrolled_students:
            # Default status is 'Absent', only change if explicitly marked as 'Present'
            status = request.POST.get(f'status_{student.id}', 'Absent')
            try:
                # Create or get Student instance
                student_instance, created = Student.objects.get_or_create(
                    name=student.user.get_full_name(),
                    department=course_teacher.department,
                    program=course_teacher.program,
                    semester=course_teacher.semester,
                    defaults={
                        'enrollment_no': student.user.username,
                        'roll_no': student.user.username
                    }
                )
                
                # Create attendance record with current date and time
                Attendance.objects.create(
                    course=course,
                    student=student_instance,
                    date=current_date,
                    status=status,
                    marked_at=current_datetime
                )
                if status == 'Present':
                    present_count += 1
                else:
                    absent_count += 1

                # --- Notification Logic ---
                # Calculate attendance percentage for this student in this course
                total_classes = Attendance.objects.filter(course=course, student=student_instance).count()
                present_classes = Attendance.objects.filter(course=course, student=student_instance, status='Present').count()
                attendance_percentage = (present_classes / total_classes) * 100 if total_classes > 0 else 0
                from attendance.models import Notification
                if attendance_percentage < 75:
                    message = f"You are requested to attend the classes of {course.name} because your attendance in this course is {attendance_percentage:.2f}%, which is lower than the 75% criteria."
                    Notification.objects.create(
                        user=student.user,
                        title=f"Low Attendance in {course.code}",
                        message=message,
                        notification_type='general',
                        is_read=False
                    )
            except Exception as e:
                messages.error(request, f"Error saving attendance for {student.user.get_full_name()}: {str(e)}")
                return redirect('mark_attendance', course_id=course_id)

        messages.success(request, f"Attendance marked successfully! Present: {present_count}, Absent: {absent_count}")
        return redirect('view_attendance', course_id=course_id)

    # Get current time in IST
    current_time = timezone.localtime(timezone.now())
    
    return render(request, 'attendance/teacher_authentication_template/mark_attendance.html', {
        'course': course,
        'enrolled_students': enrolled_students,
        'current_datetime': current_time
    })




# ------------------------------------------------------------------------------

import csv
from django.http import HttpResponse
from .models import Attendance

@login_required
def export_attendance(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="attendance.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Student', 'Course', 'Status', 'Date'])

    for record in Attendance.objects.all():
        writer.writerow([record.student.name, record.course.name, record.status, record.date])

    return response



# ----------------------------------------------------------------------------------

from django.http import JsonResponse
from .models import Semester, Program

def get_semesters(request):
    """Returns semesters based on selected program (for dynamic dropdown)."""
    program_id = request.GET.get("program_id")
    
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
        return JsonResponse(list(semesters), safe=False)
    
    return JsonResponse({"error": "Invalid Request"}, status=400)




# -----------------------------------------------------------------------------------
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages



from .forms import EnrollmentForm

def enroll_students(request):
    if request.method == "POST":
        form = EnrollmentForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('enroll_students')
    else:
        form = EnrollmentForm()
    return render(request, 'attendance/enroll_students.html', {'form': form})




from .models import Attendance

@login_required
def view_attendance(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Order by date descending and then by time descending
    attendance_records = attendance_records.order_by('-date', '-marked_at')

    # Calculate attendance statistics for each student
    attendance_summary = {}
    
    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()
    
    for student in students:
        # Get all attendance records for this student after filtering
        student_records = attendance_records.filter(student=student)
        
        # Count total classes for this student (unique date+marked_at combinations)
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        
        # Calculate attendance percentage
        percentage = round((present_count / total_classes * 100), 2) if total_classes > 0 else 0
        
        attendance_summary[student.id] = {
            'name': student.name,
            'present_count': present_count,
            'total_classes': total_classes,
            'percentage': percentage
        }

    # Get unique dates for the date filter dropdown
    unique_dates = attendance_records.values_list('date', flat=True).distinct().order_by('-date')
    
    # Get unique student names for the student filter dropdown
    unique_students = students.values_list('name', flat=True).order_by('name')

    return render(request, 'attendance/teacher_authentication_template/view_attendance.html', {
        'course': course,
        'attendance_records': attendance_records,
        'attendance_summary': attendance_summary,
        'unique_dates': unique_dates,
        'unique_students': unique_students,
        'selected_from_date': from_date,
        'selected_to_date': to_date,
        'selected_student': student_name,
        'selected_status': status
    })



def generate_reports(request):
    return render(request, 'attendance/generate_reports.html')




from django.shortcuts import render
from django.contrib.auth.decorators import login_required





# -----------------------------------------------------------------------------------------------------------------------

from django.shortcuts import render, redirect
from django.http import JsonResponse
from .models import CourseTeacher, Program, Semester, Course
from .forms import AssignTeacherForm

from django.shortcuts import render, redirect
from .forms import AssignTeacherForm
from .models import CourseTeacher

@login_required
def assign_teacher(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    if request.method == "POST":
        try:
            teacher_id = request.POST.get('teacher')
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_ids = request.POST.getlist('courses')

            if not all([teacher_id, department_id, program_id, semester_id, course_ids]):
                messages.error(request, "All fields are required.")
                return redirect('assign_teacher')

            teacher = CustomUser.objects.get(id=teacher_id)
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)
            courses = Course.objects.filter(id__in=course_ids)

            existing_assignment = CourseTeacher.objects.filter(
                user=teacher,
                department=department,
                program=program,
                semester=semester
            ).first()

            if existing_assignment:
                existing_courses = set(existing_assignment.course.all())
                new_courses = set(courses)
                existing_assignment.course.add(*new_courses)
                new_courses_added = len(new_courses - existing_courses)
                if new_courses_added > 0:
                    # Create notification for new courses
                    for course in (new_courses - existing_courses):
                        Notification.objects.create(
                            user=teacher,
                            message=f"You have been allotted the course: {course.name} ({course.code})"
                        )
                    messages.success(request, f"Added {new_courses_added} new course(s) to existing assignment!")
                else:
                    messages.info(request, "No new courses to add - teacher already assigned to selected courses.")
            else:
                course_teacher = CourseTeacher.objects.create(
                    user=teacher,
                    department=department,
                    program=program,
                    semester=semester
                )
                course_teacher.course.set(courses)
                # Create notification for all assigned courses
                for course in courses:
                    Notification.objects.create(
                        user=teacher,
                        message=f"You have been allotted the course: {course.name} ({course.code})"
                    )
                messages.success(request, "Teacher assigned to courses successfully!")

            return redirect('assign_teacher')

        except CustomUser.DoesNotExist:
            messages.error(request, "Teacher not found")
            return redirect('assign_teacher')
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect('assign_teacher')

    # GET request - show form
    departments = Department.objects.all()
    course_assignments = CourseTeacher.objects.select_related(
        'user', 'department', 'program', 'semester'
    ).prefetch_related('course').order_by('user', 'program', 'semester')

    return render(request, 'attendance/assign_teacher.html', {
        'departments': departments,
        'course_assignments': course_assignments
    })

@login_required
def get_teachers_by_department(request, department_id=None):
    try:
        # Get department_id from URL parameter or GET request
        dept_id = department_id or request.GET.get('department_id')
        if not dept_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)

        print(f"Fetching teachers for department ID: {dept_id}") # Debug log
        
        # Get all teachers from the specified department who are not already chairpersons
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=dept_id
        ).exclude(
            chairperson__isnull=False  # Exclude teachers who are already chairpersons
        ).select_related('teacher').values('id', 'first_name', 'last_name', 'email')
        
        print(f"Found {teachers.count()} teachers") # Debug log
        
        # Format teacher names
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data}, safe=False)
    except CustomUser.DoesNotExist:
        print("No teachers found for this department") # Debug log
        return JsonResponse({'error': 'No teachers found for this department'}, status=404)
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get programs for the department
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        # Convert to list and return
        programs_list = list(programs)
        print(f"Returning data: {programs_list}") # Debug log
        
        return JsonResponse({
            'status': 'success',
            'programs': programs_list
        })
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        }, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        return JsonResponse({'semesters': list(semesters)})
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_courses(request):
    try:
        semester_id = request.GET.get('semester_id')
        program_id = request.GET.get('program_id')
        department_id = request.GET.get('department_id')
        
        if not all([semester_id, program_id, department_id]):
            return JsonResponse({'error': 'All parameters are required'}, status=400)
        
        # Get courses based on all three parameters
        courses = Course.objects.filter(
            semester_id=semester_id,
            program_id=program_id,
            department_id=department_id
        ).values('id', 'name', 'code')
        
        # Format the response
        courses_data = [{
            'id': course['id'],
            'name': f"{course['code']} - {course['name']}"
        } for course in courses]
        
        return JsonResponse({'courses': courses_data})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_teachers_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching teachers for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get all teachers from the department who have associated CustomUser accounts
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=department_id
        ).select_related('teacher').values(
            'id',
            'first_name',
            'last_name',
            'email',
            'teacher__teacher_code'
        ).order_by('first_name', 'last_name')
        
        print(f"Found {teachers.count()} teachers in department") # Debug log
        
        # Format teacher data
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'teacher_code': teacher['teacher__teacher_code'],
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data})
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching programs for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        programs = Program.objects.filter(department_id=department_id).values('id', 'name')
        print(f"Found {programs.count()} programs") # Debug log
        
        programs_data = list(programs)
        print(f"Returning data: {programs_data}") # Debug log
        
        return JsonResponse({'programs': programs_data})
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        print(f"Fetching semesters for program ID: {program_id}") # Debug log
        
        if not program_id:
            return JsonResponse({'error': 'Program ID is required'}, status=400)
            
        semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
        print(f"Found {semesters.count()} semesters") # Debug log
        
        semesters_data = list(semesters)
        return JsonResponse({'semesters': semesters_data}, safe=False)
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")  # Add logging
        return JsonResponse({'error': str(e)}, status=400)

from django.http import JsonResponse
from .models import Program

def load_programs(request):
    department_id = request.GET.get("department_id")
    programs = Program.objects.filter(department_id=department_id).values("id", "name")
    return JsonResponse(list(programs), safe=False)



from django.http import JsonResponse
from .models import Semester

def load_semesters(request):
    program_id = request.GET.get("program_id")
    semesters = Semester.objects.filter(program_id=program_id).values("id", "name")
    return JsonResponse(list(semesters), safe=False)




from django.http import JsonResponse
from .models import Course

def load_courses(request):
    semester_id = request.GET.get("semester_id")
    program_id = request.GET.get("program_id")
    department_id = request.GET.get("department_id")
    
    try:
        # Start with base query
        courses = Course.objects.all()
        
        # Apply filters if provided
        if semester_id:
            courses = courses.filter(semester_id=semester_id)
        if program_id:
            courses = courses.filter(program_id=program_id)
        if department_id:
            courses = courses.filter(department_id=department_id)
        
        # Get required fields
        courses = courses.values("id", "name", "code")
        
        return JsonResponse(list(courses), safe=False)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)





from django.shortcuts import render
from .models import CourseTeacher

@login_required
def teacher_dashboard(request):
    if request.user.role not in ['faculty', 'chairperson']:
        messages.error(request, "You are not authorized to access this page.")
        return redirect('home')
    
    try:
        # Get teacher's course assignments
        course_assignments = CourseTeacher.objects.filter(
            user=request.user
        ).select_related(
            'department', 'program', 'semester'
        ).prefetch_related('course').order_by('program', 'semester')
        
        # Calculate total number of courses
        total_courses = sum(assignment.course.count() for assignment in course_assignments)
        
        # Get all notifications for the user
        all_notifications = Notification.objects.filter(user=request.user)
        
        # Get unread count
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        
        # Get recent notifications separately
        recent_notifications = Notification.objects.filter(
            user=request.user
        ).order_by('-created_at')[:10]
        
        # Get attendance change requests for courses taught by this teacher
        assigned_courses = []
        for assignment in course_assignments:
            assigned_courses.extend(assignment.course.all())
        
        attendance_change_requests = AttendanceChangeRequest.objects.filter(
            course__in=assigned_courses,
            status='pending'
        ).select_related('student', 'course').order_by('-created_at')
        
        context = {
            'course_assignments': course_assignments,
            'total_courses': total_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count,
            'user': request.user,
            'attendance_change_requests': attendance_change_requests
        }
        
        return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', context)
        
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('unified_login')

@login_required
def view_course_students(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    enrolled_students = EnrollStudent.objects.filter(
        courses=course,
        department=course_teacher.department,
        program=course_teacher.program,
        semester=course_teacher.semester
    ).select_related('user')

    if request.method == "POST":
        date = request.POST.get('date')
        for student in enrolled_students:
            status = request.POST.get(f'status_{student.id}', 'Absent')
            Attendance.objects.create(
                course=course,
                student=student.user,
                date=date,
                status=status
            )
        messages.success(request, "Attendance marked successfully!")
        return redirect('view_course_students', course_id=course_id)

    return render(request, 'attendance/teacher_authentication_template/course_students.html', {
        'course': course,
        'enrolled_students': enrolled_students
    })

def register_admin(request):
    if request.method == 'POST':
        form = AdminRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.role = "admin"  # Set role to admin
            user.is_staff = True  # Set is_staff to True
            user.save()
            login(request, user)
            return redirect('admin_dashboard')
    else:
        form = AdminRegistrationForm()
    return render(request, 'attendance/admin_authentication_template/register_admin.html', {'form': form})

@login_required
def remove_course_assignment(request, assignment_id):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    try:
        assignment = CourseTeacher.objects.get(id=assignment_id)
        assignment.delete()
        messages.success(request, "Course assignment removed successfully!")
    except CourseTeacher.DoesNotExist:
        messages.error(request, "Course assignment not found.")
    except Exception as e:
        messages.error(request, f"Error removing assignment: {str(e)}")

    return redirect('assign_teacher')

@login_required
def export_attendance_csv(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.csv"'
    
    writer = csv.writer(response)
    
    # Write filter information
    writer.writerow(['Attendance Summary - Filter Details'])
    writer.writerow(['Course:', f'{course.name} ({course.code})'])
    writer.writerow(['Department:', course.department.name])
    writer.writerow(['Program:', course.program.name])
    writer.writerow(['Semester:', course.semester.name])
    writer.writerow([])  # Empty row for spacing
    
    if from_date or to_date or student_name or status:
        writer.writerow(['Applied Filters:'])
        if from_date and to_date:
            writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
        if student_name:
            writer.writerow(['Student:', student_name])
        if status:
            writer.writerow(['Status:', status])
        writer.writerow([])  # Empty row for spacing
    
    # Write table header
    writer.writerow(['Sr. No.', 'Student Name', 'Present', 'Classes', '%'])
    
    # Calculate attendance for each student
    for index, student in enumerate(students, 1):
        student_records = attendance_records.filter(student=student)
        # Count total classes for this student
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        # Calculate attendance percentage
        attendance_percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
        writer.writerow([index, student.name, str(present_count), str(total_classes), f'{attendance_percentage}%'])
    
    return response

@login_required
def export_attendance_pdf(request, course_id):
    if request.user.role != "faculty":
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')

    course = get_object_or_404(Course, id=course_id)
    course_teacher = get_object_or_404(CourseTeacher, user=request.user, course=course)
    
    # Get filter parameters
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    student_name = request.GET.get('student')
    status = request.GET.get('status')

    # Get base query for attendance records
    attendance_records = Attendance.objects.filter(course=course).select_related('student')

    # Apply filters to attendance records
    if from_date and to_date:
        attendance_records = attendance_records.filter(date__range=[from_date, to_date])
    elif from_date:
        attendance_records = attendance_records.filter(date=from_date)
    
    if student_name:
        attendance_records = attendance_records.filter(student__name__icontains=student_name)
    if status:
        attendance_records = attendance_records.filter(status=status)

    # Get all unique students who have attendance records
    students = Student.objects.filter(attendance__course=course).distinct()

    # Create PDF response
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="attendance_summary_{course.code}_{from_date}_to_{to_date}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    
    # Define styles
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Title'],
        fontSize=14,
        spaceAfter=12,
        alignment=1
    )
    
    # Add filter information
    elements.append(Paragraph("Attendance Summary - Filter Details", title_style))
    elements.append(Spacer(1, 12))
    
    # Add course information
    course_info = [
        f"Course: {course.name} ({course.code})",
        f"Department: {course.department.name}",
        f"Program: {course.program.name}",
        f"Semester: {course.semester.name}"
    ]
    for info in course_info:
        elements.append(Paragraph(info, styles['Normal']))
        elements.append(Spacer(1, 6))
    
    elements.append(Spacer(1, 12))
    
    # Add filter information if any filters are applied
    if from_date or to_date or student_name or status:
        elements.append(Paragraph("Applied Filters:", styles['Heading3']))
        if from_date and to_date:
            elements.append(Paragraph(f"Date Range: {from_date} to {to_date}", styles['Normal']))
        if student_name:
            elements.append(Paragraph(f"Student: {student_name}", styles['Normal']))
        if status:
            elements.append(Paragraph(f"Status: {status}", styles['Normal']))
        elements.append(Spacer(1, 12))
    
    # Create table data
    table_data = [['Sr. No.', 'Student Name', 'Present', 'Classes', '%']]
    
    # Calculate attendance for each student
    for index, student in enumerate(students, 1):
        student_records = attendance_records.filter(student=student)
        # Count total classes for this student
        total_classes = student_records.values('date', 'marked_at').distinct().count()
        # Count present sessions for this student
        present_count = student_records.filter(status='Present').values('date', 'marked_at').distinct().count()
        # Calculate attendance percentage
        attendance_percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
        table_data.append([str(index), student.name, str(present_count), str(total_classes), f'{attendance_percentage}%'])
    
    # Create table with column widths
    col_widths = [40, '*', 80, 80, 100]  # Sr. No. column smaller, Student Name column flexible
    table = Table(table_data, colWidths=col_widths)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 12),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    elements.append(table)
    
    # Build PDF
    doc.build(elements)
    pdf = buffer.getvalue()
    buffer.close()
    response.write(pdf)
    
    return response

@login_required
def edit_course_assignment(request, assignment_id):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    assignment = get_object_or_404(CourseTeacher, id=assignment_id)
    
    if request.method == 'POST':
        try:
            # Get selected course IDs from the form
            course_ids = request.POST.getlist('courses')
            
            # Get program and semester
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            
            # Update program and semester
            if program_id:
                assignment.program = get_object_or_404(Program, id=program_id)
            if semester_id:
                assignment.semester = get_object_or_404(Semester, id=semester_id)
            
            # Update courses
            courses = Course.objects.filter(id__in=course_ids)
            assignment.course.set(courses)
            
            assignment.save()
            messages.success(request, "Course assignment updated successfully!")
            return redirect('assign_teacher')
            
        except Exception as e:
            messages.error(request, f"Error updating course assignment: {str(e)}")
            return redirect('assign_teacher')
    
    # GET request - show edit form
    departments = Department.objects.all()
    programs = Program.objects.filter(department=assignment.department)
    semesters = Semester.objects.filter(program=assignment.program) if assignment.program else Semester.objects.none()
    
    # Get all courses for the current semester, program, and department
    all_courses = Course.objects.filter(
        semester=assignment.semester,
        program=assignment.program,
        department=assignment.department
    )
    
    return render(request, 'attendance/admin_authentication_template/edit_course_assignment.html', {
        'assignment': assignment,
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'all_courses': all_courses
    })

@login_required
def attendance_summary(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        
    departments = Department.objects.all()
    programs = Program.objects.none()
    semesters = Semester.objects.none()
    courses = Course.objects.none()
    
    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    selected_courses = request.GET.getlist('courses')
    
    # Convert selected_courses to integers and filter out invalid values
    try:
        selected_courses = [int(course_id) for course_id in selected_courses if course_id and course_id.isdigit()]
    except (ValueError, TypeError):
        selected_courses = []
    
    # Get programs based on selected department
    if department_id:
        programs = Program.objects.filter(department_id=department_id)
    
    # Get semesters based on selected program
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id)
    
    # Get courses based on selected semester
    if semester_id:
        courses = Course.objects.filter(semester_id=semester_id)
    
    # Initialize context
    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'courses': courses,
        'selected_department': department_id,
        'selected_program': program_id,
        'selected_semester': semester_id,
        'selected_courses': selected_courses,
        'from_date': from_date,
        'to_date': to_date
    }
    
    # If filters are applied
    if department_id and program_id and semester_id and from_date and to_date:
        try:
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id, department=department)
            semester = Semester.objects.get(id=semester_id, program=program)
            
            # Get courses based on filter
            if selected_courses:
                courses = Course.objects.filter(id__in=selected_courses, semester=semester)
            else:
                courses = Course.objects.filter(semester=semester)
            
            # Calculate total classes for each course
            for course in courses:
                # Get all attendance records for this course
                attendance_records = Attendance.objects.filter(
                    course=course,
                    date__range=[from_date, to_date]
                )
                
                # Count how many times each student name appears
                student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
                
                # Get the maximum count (this will be the total classes for this course)
                course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            
            # Get all enrolled students for the program and semester
            enroll_students = EnrollStudent.objects.filter(
                program=program,
                semester=semester
            ).select_related('user')
            
            students = []
            for enroll_student in enroll_students:
                try:
                    # Get the Student model instance using the enrollment number
                    student = Student.objects.get(
                        enrollment_no=enroll_student.user.username,
                        program=program,
                        semester=semester
                    )
                    
                    student_info = {
                        'name': student.name,
                        'courses': [],
                        'total_classes': 0,
                        'total_present': 0,
                        'overall_percentage': 0
                    }
                    
                    for course in courses:
                        # Get attendance records for this student and course
                        attendance_records = Attendance.objects.filter(
                            student=student,
                            course=course,
                            date__range=[from_date, to_date]
                        )
                        
                        # Count total classes and present count for this student and course
                        total_classes = attendance_records.count()
                        present_count = attendance_records.filter(status='Present').count()
                        percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                        
                        student_info['courses'].append({
                            'name': course.name,
                            'total_classes': total_classes,
                            'present_count': present_count,
                            'percentage': percentage
                        })
                        
                        student_info['total_classes'] += total_classes
                        student_info['total_present'] += present_count
                    
                    if student_info['total_classes'] > 0:
                        student_info['overall_percentage'] = round(
                            (student_info['total_present'] / student_info['total_classes'] * 100), 2
                        )
                    
                    students.append(student_info)
                except Student.DoesNotExist:
                    # Skip students that don't have a corresponding Student record
                    continue
            
            # Calculate total classes across all courses
            total_classes = sum(course.total_classes for course in courses)
            
            context.update({
                'department': department,
                'program': program,
                'semester': semester,
                'courses': courses,
                'students': students,
                'total_classes': total_classes,
                'has_data': True  # Add flag to indicate data is available
            })
            
        except (Program.DoesNotExist, Semester.DoesNotExist) as e:
            messages.error(request, str(e))
    
    return render(request, 'attendance/admin_authentication_template/attendance_summary.html', context)

@login_required
def attendance_report(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')
    
    departments = Department.objects.all()
    programs = Program.objects.all()
    semesters = Semester.objects.all()
    
    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    
    # Initialize context
    context = {
        'departments': departments,
        'programs': programs,
        'semesters': semesters,
        'selected_department': department_id,
        'selected_program': program_id,
        'selected_semester': semester_id,
        'from_date': from_date,
        'to_date': to_date
    }
    
    # If filters are applied
    if department_id and program_id and semester_id and from_date and to_date:
        try:
            department = Department.objects.get(id=department_id)
            program = Program.objects.get(id=program_id)
            semester = Semester.objects.get(id=semester_id)
            
            # Get all courses for the semester
            courses = Course.objects.filter(semester=semester)
            
            # Calculate total classes for each course
            for course in courses:
                # Get all attendance records for this course
                attendance_records = Attendance.objects.filter(
                    course=course,
                    date__range=[from_date, to_date]
                )
                
                # Count how many times each student name appears
                student_counts = attendance_records.values('student__first_name', 'student__last_name').annotate(count=Count('id'))
                
                # Get the maximum count (this will be the total classes for this course)
                course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            
            # Get all enrolled students for the program and semester
            enroll_students = EnrollStudent.objects.filter(
                program=program,
                semester=semester
            ).select_related('user')
            
            students = []
            for enroll_student in enroll_students:
                student = enroll_student.user
                student_info = {
                    'name': f"{student.first_name} {student.last_name}",
                    'courses': [],
                    'total_classes': 0,
                    'total_present': 0,
                    'overall_percentage': 0
                }
                
                for course in courses:
                    # Get attendance records for this student and course
                    attendance_records = Attendance.objects.filter(
                        student__first_name=student.first_name,
                        student__last_name=student.last_name,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    # Count total classes and present count for this student and course
                    total_classes = attendance_records.count()
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    student_info['courses'].append({
                        'name': course.name,
                        'total_classes': total_classes,
                        'present_count': present_count,
                        'percentage': percentage
                    })
                    
                    student_info['total_classes'] += total_classes
                    student_info['total_present'] += present_count
                
                if student_info['total_classes'] > 0:
                    student_info['overall_percentage'] = round(
                        (student_info['total_present'] / student_info['total_classes'] * 100), 2
                    )
                
                students.append(student_info)
            
            # Calculate total classes across all courses
            total_classes = sum(course.total_classes for course in courses)
            
            context.update({
                'department': department,
                'program': program,
                'semester': semester,
                'courses': courses,
                'students': students,
                'total_classes': total_classes
            })
            
        except Exception as e:
            messages.error(request, f"Error generating report: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/attendance_report.html', context)

@login_required
def export_attendance_csv_admin(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')

    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')

    if not all([department_id, program_id, semester_id, from_date, to_date]):
        messages.error(request, "All filter parameters are required")
        return redirect('attendance_report')

    try:
        department = Department.objects.get(id=department_id)
        program = Program.objects.get(id=program_id)
        semester = Semester.objects.get(id=semester_id)

        # Get all courses for the semester
        courses = Course.objects.filter(semester=semester)

        # Calculate total classes for each course
        for course in courses:
            # Get all attendance records for this course
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            
            # Count how many times each student name appears
            student_counts = attendance_records.values('student__first_name', 'student__last_name').annotate(count=Count('id'))
            
            # Get the maximum count (this will be the total classes for this course)
            course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0

        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="attendance_report_{from_date}_to_{to_date}.csv"'
        
        writer = csv.writer(response)
        
        # Write filter information
        writer.writerow(['Attendance Report'])
        writer.writerow(['Department:', department.name])
        writer.writerow(['Program:', program.name])
        writer.writerow(['Semester:', semester.name])
        writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
        writer.writerow([])  # Empty row for spacing
        
        # Calculate total classes across all courses
        total_classes_all = sum(course.total_classes for course in courses)
        
        # Write header row
        header = ['Sr. No.', 'Student Name']
        for course in courses:
            header.extend([
                f'{course.code} - Present out of {course.total_classes}',
                f'{course.code} - %'
            ])
        header.extend([f'Total Present out of {total_classes_all}', 'Overall %'])
        writer.writerow(header)
        
        # Write data rows
        for index, enroll_student in enumerate(enroll_students, 1):
            student = enroll_student.user
            student_name = f"{student.first_name} {student.last_name}"
            row = [index, student_name]
            
            total_present = 0
            total_classes = 0
            
            for course in courses:
                attendance_records = Attendance.objects.filter(
                    student__first_name=student.first_name,
                    student__last_name=student.last_name,
                    course=course,
                    date__range=[from_date, to_date]
                )
                
                course_total = attendance_records.count()
                course_present = attendance_records.filter(status='Present').count()
                percentage = round((course_present / course_total * 100) if course_total > 0 else 0, 2)
                
                row.extend([course_present, f'{percentage}%'])
                total_present += course_present
                total_classes += course_total
            
            overall_percentage = round((total_present / total_classes * 100) if total_classes > 0 else 0, 2)
            row.extend([str(total_present), f'{overall_percentage}%'])
            
            writer.writerow(row)
        
        return response
        
    except Exception as e:
        messages.error(request, f"Error generating CSV: {str(e)}")
        return redirect('attendance_report')

@login_required
def export_attendance_pdf_admin(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')
    
    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    
    if not all([department_id, program_id, semester_id, from_date, to_date]):
        messages.error(request, "All filter parameters are required")
        return redirect('attendance_report')
    
    try:
        department = Department.objects.get(id=department_id)
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get all courses for the semester
        courses = Course.objects.filter(semester=semester)
        
        # Calculate total classes for each course
        course_total_classes = {}
        total_classes_all = 0
        for course in courses:
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
            total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            course_total_classes[course.id] = total_classes
            total_classes_all += total_classes
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Create PDF response
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="attendance_report_{from_date}_to_{to_date}.pdf"'
        
        # Calculate page size based on number of courses
        num_courses = len(courses)
        if num_courses <= 2:
            page_size = letter
        elif num_courses <= 4:
            page_size = landscape(letter)
        else:
            # For more than 4 courses, use a custom size
            page_size = landscape((11 * inch, 17 * inch))  # Wider page for more courses
        
        # Create PDF document with appropriate page size
        doc = SimpleDocTemplate(
            response,
            pagesize=page_size,
            leftMargin=0.5*inch,
            rightMargin=0.5*inch,
            topMargin=0.5*inch,
            bottomMargin=0.5*inch
        )
        elements = []
        
        # Add title
        title = f"Attendance Report - {program.name} - {semester.name}"
        elements.append(Paragraph(title, getSampleStyleSheet()['Title']))
        
        # Add filter details
        details = [
            ['Department:', department.name, 'Program:', program.name],
            ['Semester:', semester.name, 'Date Range:', f'{from_date} to {to_date}']
        ]
        
        details_table = Table(details, colWidths=[1.2*inch, 1.8*inch, 1.2*inch, 1.8*inch])
        details_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 7),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(filter_table)
        elements.append(Spacer(1, 12))
        
        # Create table data with wrapped text for headers
        table_data = [['Sr. No.', 'Student Name']]
        for course in courses:
            course_info = f'{course.code}\nPresent out of {course.total_classes}'
            table_data[0].extend([course_info, '%'])
        table_data[0].extend([f'Total Present\nout of {total_classes_all}', 'Overall %'])
        
        # Process data
        for index, enroll_student in enumerate(enroll_students, 1):
            student = enroll_student.user
            student_name = f"{student.first_name} {student.last_name}"
            if len(student_name) > 15:  # Limit student name length
                student_name = student_name[:15] + '...'
            
            row = [str(index), student_name]
            total_present = 0
            total_classes = 0
            
            for course in courses:
                attendance_records = Attendance.objects.filter(
                    student__first_name=student.first_name,
                    student__last_name=student.last_name,
                    course=course,
                    date__range=[from_date, to_date]
                )
                course_total = attendance_records.count()
                course_present = attendance_records.filter(status='Present').count()
                percentage = round((course_present / course_total * 100) if course_total > 0 else 0, 2)
                row.extend([str(course_present), f'{percentage}%'])
                total_present += course_present
                total_classes += course_total
            
            overall_percentage = round((total_present / total_classes * 100) if total_classes > 0 else 0, 2)
            row.extend([str(total_present), f'{overall_percentage}%'])
            
            table_data.append(row)
            row_number += 1
        
        # Split columns into two parts for better PDF layout
        num_columns = len(table_data[0])
        mid_column = (num_columns - 2) // 2  # Exclude Sr. No. and Student Name columns
        
        # First page columns
        table_data_page1 = []
        for row in table_data:
            table_data_page1.append(row[:mid_column + 2])  # Include Sr. No. and Student Name columns
        
        # Second page columns
        table_data_page2 = []
        for row in table_data:
            table_data_page2.append([row[0], row[1]] + row[mid_column + 2:])  # Include Sr. No. and Student Name columns
        
        # Calculate optimized column widths for first page
        col_widths_page1 = [0.25*inch]  # Sr. No. column
        col_widths_page1.append(0.7*inch)  # Student Name column
        for _ in range((mid_column) // 2):
            col_widths_page1.extend([0.8*inch, 0.3*inch])  # Course columns
        
        # Create first table
        table1 = Table(table_data_page1, colWidths=col_widths_page1)
        table1.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 7),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 30),
            ('TOPPADDING', (0, 0), (-1, 0), 30),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 7),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 3),
            ('RIGHTPADDING', (0, 0), (-1, -1), 3),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
            ('WORDWRAP', (0, 0), (-1, -1), True),
            ('MINIMUMHEIGHT', (0, 0), (-1, 0), 1.5*inch),
            ('LEADING', (0, 0), (-1, 0), 8),  # Reduced line spacing for header row
        ]))
        
        elements.append(table1)
        elements.append(PageBreak())
        
        # Calculate optimized column widths for second page
        col_widths_page2 = [0.25*inch]  # Sr. No. column
        col_widths_page2.append(0.7*inch)  # Student Name column
        for _ in range((num_columns - mid_column - 2) // 2):
            col_widths_page2.extend([0.8*inch, 0.3*inch])  # Course columns
        
        # Create second table
        table2 = Table(table_data_page2, colWidths=col_widths_page2)
        table2.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 7),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 30),
            ('TOPPADDING', (0, 0), (-1, 0), 30),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 7),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 3),
            ('RIGHTPADDING', (0, 0), (-1, -1), 3),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
            ('WORDWRAP', (0, 0), (-1, -1), True),
            ('MINIMUMHEIGHT', (0, 0), (-1, 0), 1.5*inch),
            ('LEADING', (0, 0), (-1, 0), 8),  # Reduced line spacing for header row
        ]))
        
        elements.append(table2)
        
        # Build PDF
        doc.build(elements)
        
        pdf = buffer.getvalue()
        buffer.close()
        response.write(pdf)
        return response
        
    except Exception as e:
        messages.error(request, f"Error generating PDF: {str(e)}")
        return redirect('attendance_report')



# Chairperson Authentication Views
def register_chairperson(request):
    if request.method == 'POST':
        form = ChairpersonRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(request, "Registration successful! Please wait for admin approval.")
            return redirect('chairperson_login')
    else:
        form = ChairpersonRegistrationForm()
    
    departments = Department.objects.all()
    return render(request, 'attendance/chairperson_authentication_template/register_chairperson.html', {
        'form': form,
        'departments': departments
    })

def chairperson_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            try:
                chairperson = Chairperson.objects.get(user=user)
                if chairperson.is_approved:
                    # Ensure the user's role is set to chairperson
                    if user.role != 'chairperson':
                        user.role = 'chairperson'
                        user.save()
                    
                    login(request, user)
                    
                    # Check if this is the first login (using default password)
                    if password == "password123":
                        request.session['first_login'] = True
                        messages.warning(request, "Please change your password for security.")
                    
                    # Set role in session
                    request.session['user_role'] = 'chairperson'
                    request.session['chairperson_department'] = chairperson.department.name
                    return redirect('chairperson_dashboard')
                else:
                    messages.error(request, "Your account is pending approval from the admin.")
            except Chairperson.DoesNotExist:
                messages.error(request, "Chairperson profile not found.")
        else:
            messages.error(request, "Invalid credentials or unauthorized access.")
    
    return render(request, 'attendance/chairperson_authentication_template/chairperson_login.html')

def chairperson_required(view_func):
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            messages.error(request, "Please log in first.")
            return redirect('unified_login')
        
        if request.user.role != 'chairperson':
            messages.error(request, "Access denied. This page is for chairpersons only.")
            return redirect('unified_login')
        
        try:
            chairperson = Chairperson.objects.get(user=request.user, is_approved=True)
            request.chairperson = chairperson
        except Chairperson.DoesNotExist:
            messages.error(request, "Chairperson profile not found or not approved.")
            return redirect('unified_login')
        
        return view_func(request, *args, **kwargs)
    return wrapper

@login_required
@chairperson_required
def chairperson_dashboard(request):
    try:
        # Get department statistics
        department = request.chairperson.department
        total_programs = Program.objects.filter(department=department).count()
        total_teachers = Teacher.objects.filter(department=department).count()
        total_students = Student.objects.filter(department=department).count()
        total_courses = Course.objects.filter(program__department=department).count()
        
        # Get pending attendance change requests for this department
        pending_requests = AttendanceChangeRequest.objects.filter(
            status='pending',
            course__program__department=department
        ).select_related(
            'faculty', 'student', 'course'
        ).order_by('-created_at')[:5]  # Get latest 5 pending requests
        
        pending_requests_count = AttendanceChangeRequest.objects.filter(
            status='pending',
            course__program__department=department
        ).count()
        
        # Get recent activities
        recent_activities = []
        
        # Add recent program activities
        recent_programs = Program.objects.filter(department=department).order_by('-id')[:2]
        for program in recent_programs:
            recent_activities.append({
                'title': f'New Program: {program.name}',
                'description': f'Department: {program.department.name}',
                'time': 'Recently added'
            })
        
        # Add recent teacher activities
        recent_teachers = Teacher.objects.filter(department=department).order_by('-id')[:2]
        for teacher in recent_teachers:
            recent_activities.append({
                'title': f'New Teacher: {teacher.name}',
                'description': f'Teacher code: {teacher.teacher_code}',
                'time': 'Recently added'
            })
        
        # Add recent course activities
        recent_courses = Course.objects.filter(program__department=department).order_by('-id')[:2]
        for course in recent_courses:
            recent_activities.append({
                'title': f'New Course: {course.name}',
                'description': f'Course code: {course.code}',
                'time': 'Recently added'
            })
        
        # Sort activities by ID and get the 5 most recent
        recent_activities.sort(key=lambda x: x['title'], reverse=True)
        recent_activities = recent_activities[:5]
        
        context = {
            'chairperson': request.chairperson,
            'department': department,
            'total_programs': total_programs,
            'total_teachers': total_teachers,
            'total_students': total_students,
            'total_courses': total_courses,
            'recent_activities': recent_activities,
            'pending_requests': pending_requests,
            'pending_requests_count': pending_requests_count,
        }
        
        return render(request, 'attendance/chairperson_authentication_template/chairperson_dashboard.html', context)
        
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('unified_login')

@login_required
@chairperson_required
def chairperson_manage_teachers(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get all teachers for this department
    teachers = Teacher.objects.filter(department=department)

    if request.method == "POST":
        teacher_code = request.POST.get('teacher_code')
        name = request.POST.get('name')
        # Department is fixed to chairperson's department

        # Check if teacher_code already exists
        if Teacher.objects.filter(teacher_code=teacher_code).exists():
            messages.error(request, "Teacher code already exists!")
        else:
            teacher = Teacher.objects.create(
                teacher_code=teacher_code, 
                name=name, 
                department=department
            )
            messages.success(request, f"Teacher {teacher.name} (Code: {teacher.teacher_code}) added successfully!")
            return redirect('chairperson_manage_teachers')

    return render(request, "attendance/chairperson_authentication_template/manage_teachers.html", {
        "department": department, 
        "teachers": teachers
    })

@login_required
@chairperson_required
def chairperson_edit_teacher(request, teacher_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        teacher = Teacher.objects.get(id=teacher_id, department=department)
    except Teacher.DoesNotExist:
        messages.error(request, "Teacher not found or you don't have permission to edit it.")
        return redirect('chairperson_manage_teachers')
    
    if request.method == "POST":
        teacher_code = request.POST.get('teacher_code')
        name = request.POST.get('name')
        
        # Check if teacher_code already exists (excluding current teacher)
        if Teacher.objects.filter(teacher_code=teacher_code).exclude(id=teacher_id).exists():
            messages.error(request, "Teacher code already exists!")
            return redirect('chairperson_edit_teacher', teacher_id=teacher_id)
        
        # Update teacher
        teacher.teacher_code = teacher_code
        teacher.name = name
        teacher.save()
        
        messages.success(request, f"Teacher {teacher.name} updated successfully!")
        return redirect('chairperson_manage_teachers')
    
    return render(request, "attendance/chairperson_authentication_template/edit_teacher.html", {
        "teacher": teacher,
        "department": department
    })

@login_required
@chairperson_required
def chairperson_delete_teacher(request, teacher_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        teacher = Teacher.objects.get(id=teacher_id, department=department)
        
        # Check if teacher has any course assignments by matching teacher_code with CustomUser username
        if CourseTeacher.objects.filter(user__username=teacher.teacher_code).exists():
            messages.error(request, "Cannot delete teacher because they have course assignments. Please remove all assignments first.")
            return redirect('chairperson_manage_teachers')
        
        # Delete teacher
        teacher_name = teacher.name
        teacher.delete()
        
        messages.success(request, f"Teacher {teacher_name} deleted successfully!")
        
    except Teacher.DoesNotExist:
        messages.error(request, "Teacher not found or you don't have permission to delete it.")
    except Exception as e:
        messages.error(request, f"Error deleting teacher: {str(e)}")
    
    return redirect('chairperson_manage_teachers')

@login_required
@chairperson_required
def chairperson_manage_courses(request):
    if not hasattr(request.user, 'chairperson'):
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('login')
    
    chairperson = request.user.chairperson
    department = chairperson.department
    
    # Get all programs in the chairperson's department
    programs = Program.objects.filter(department=department)
    
    # Get all courses in the chairperson's department
    courses = Course.objects.filter(department=department)
    
    # Get selected program and semester
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    
    # Initialize semesters as empty queryset
    semesters = Semester.objects.none()
    
    # If a program is selected, get its semesters
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id)
        courses = courses.filter(program_id=program_id)
    
    # If a semester is selected, filter courses
    if semester_id:
        courses = courses.filter(semester_id=semester_id)
    
    context = {
        'department': department,
        'programs': programs,
        'courses': courses,
        'semesters': semesters,
        'selected_program': program_id,
        'selected_semester': semester_id,
    }
    
    return render(request, 'attendance/chairperson_authentication_template/manage_courses.html', context)

@login_required
@chairperson_required
def chairperson_manage_students(request):
    chairperson = request.chairperson
    students = Student.objects.filter(department=chairperson.department)
    return render(request, 'attendance/manage_student_template/manage_students.html', {
        'students': students,
        'departments': [chairperson.department]  # Only show chairperson's department
    })

@login_required
@chairperson_required
def chairperson_assign_teacher(request):
    chairperson = request.chairperson
    department = chairperson.department

    if request.method == "POST":
        try:
            teacher_id = request.POST.get('teacher')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_ids = request.POST.getlist('courses')

            if not all([teacher_id, program_id, semester_id, course_ids]):
                messages.error(request, "All fields are required.")
                return redirect('chairperson_assign_teacher')

            # Get teacher and verify they belong to the chairperson's department
            teacher = CustomUser.objects.get(id=teacher_id, role='faculty')
            teacher_profile = Teacher.objects.get(user=teacher)
            if teacher_profile.department != department:
                messages.error(request, "You can only assign teachers from your department.")
                return redirect('chairperson_assign_teacher')

            program = Program.objects.get(id=program_id, department=department)
            semester = Semester.objects.get(id=semester_id)
            courses = Course.objects.filter(id__in=course_ids, department=department)

            # Check if teacher already has assignments for this program and semester
            existing_assignment = CourseTeacher.objects.filter(
                user=teacher,
                department=department,
                program=program,
                semester=semester
            ).first()

            if existing_assignment:
                # Get existing courses
                existing_courses = set(existing_assignment.course.all())
                new_courses = set(courses)
                
                # Add all new courses to the existing assignment
                existing_assignment.course.add(*new_courses)
                
                # Count how many new courses were added
                new_courses_added = len(new_courses - existing_courses)
                if new_courses_added > 0:
                    messages.success(request, f"Added {new_courses_added} new course(s) to existing assignment!")
                else:
                    messages.info(request, "No new courses to add - teacher already assigned to selected courses.")
            else:
                # Create new assignment for different program/semester
                course_teacher = CourseTeacher.objects.create(
                    user=teacher,
                    department=department,
                    program=program,
                    semester=semester
                )
                course_teacher.course.set(courses)
                messages.success(request, "Teacher assigned to courses successfully!")

            return redirect('chairperson_assign_teacher')

        except CustomUser.DoesNotExist:
            messages.error(request, "Teacher not found")
            return redirect('chairperson_assign_teacher')
        except Teacher.DoesNotExist:
            messages.error(request, "Teacher profile not found")
            return redirect('chairperson_assign_teacher')
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect('chairperson_assign_teacher')

    # GET request - show form
    # Get programs for the chairperson's department
    programs = Program.objects.filter(department=department)
    course_assignments = CourseTeacher.objects.select_related(
        'user', 'department', 'program', 'semester'
    ).prefetch_related('course').filter(department=department).order_by('user', 'program', 'semester')

    return render(request, 'attendance/chairperson_authentication_template/assign_teacher.html', {
        'department': department,
        'programs': programs,
        'course_assignments': course_assignments
    })

@login_required
@user_passes_test(lambda u: u.is_superuser)
def manage_chairpersons(request):
    departments = Department.objects.all()
    chairpersons = Chairperson.objects.all().order_by('department__name')
    
    if request.method == 'POST':
        teacher_id = request.POST.get('teacher_id')
        department_id = request.POST.get('department_id')
        
        try:
            # Get the teacher user and department
            teacher_user = CustomUser.objects.get(id=teacher_id, role='faculty')
            department = Department.objects.get(id=department_id)
            
            # Get the teacher profile
            teacher = Teacher.objects.get(user=teacher_user)
            
            # Check if teacher belongs to the selected department
            if teacher.department != department:
                messages.error(request, "Selected teacher does not belong to the chosen department.")
                return redirect('manage_chairpersons')
            
            # Check if department already has a chairperson
            if Chairperson.objects.filter(department=department, is_approved=True).exists():
                messages.error(request, f"Department {department.name} already has a chairperson.")
                return redirect('manage_chairpersons')
            
            # Create chairperson username using email
            original_email = teacher_user.email
            chairperson_email = original_email.replace('@', '_chairperson@')
            chairperson_username = f"{teacher_user.username}_chairperson"
            
            # Create temporary password
            temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            
            # Create new user for chairperson role
            chairperson_user = CustomUser.objects.create_user(
                username=chairperson_username,
                email=chairperson_email,
                password=temp_password,
                first_name=teacher_user.first_name,
                last_name=teacher_user.last_name,
                role='chairperson'
            )
            
            # Create chairperson profile
            chairperson = Chairperson.objects.create(
                user=chairperson_user,
                department=department,
                teacher_code=teacher.teacher_code,
                is_approved=True
            )
            
            # Create detailed notification message
            notification_message = f"""
Congratulations! You have been appointed as the Chairperson of {department.name} department.

Your Chairperson Login Credentials:
Username: {chairperson_username}
Password: {temp_password}

Please log in to the unified login page with these credentials.
For security reasons, you will be required to change your password upon first login.

Note: This is a separate account for your chairperson role. You can continue to use your faculty account ({teacher_user.username}) for faculty-related activities.
            """
            
            # Create notification for the teacher's faculty account
            Notification.objects.create(
                user=teacher_user,
                title=f"Chairperson Appointment - {department.name}",
                message=notification_message,
                notification_type='appointment'
            )
            
            # Send email notification to faculty email
            try:
                send_mail(
                    f"Chairperson Appointment - {department.name}",
                    notification_message,
                    settings.DEFAULT_FROM_EMAIL,
                    [original_email],
                    fail_silently=False,
                )
            except Exception as e:
                print(f"Error sending email: {str(e)}")
                # Continue even if email fails
            
            messages.success(request, f"Successfully appointed {teacher_user.get_full_name()} as Chairperson of {department.name}")
            return redirect('manage_chairpersons')
            
        except CustomUser.DoesNotExist:
            messages.error(request, "Selected teacher not found.")
        except Teacher.DoesNotExist:
            messages.error(request, "Teacher profile not found.")
        except Department.DoesNotExist:
            messages.error(request, "Selected department not found.")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/admin_authentication_template/manage_chairpersons.html', {
        'departments': departments,
        'chairpersons': chairpersons
    })

@login_required
@user_passes_test(lambda u: u.is_superuser)
def remove_chairperson(request, chairperson_id):
    try:
        chairperson = Chairperson.objects.select_related('user', 'department').get(id=chairperson_id)
        department_name = chairperson.department.name
        chairperson_user = chairperson.user
        
        # Get the original teacher user
        teacher_user = CustomUser.objects.get(
            username=chairperson_user.username.replace('_chairperson', ''),
            role='faculty'
        )
        
        # Create removal notification message
        notification_message = f"""
Your chairperson role for {department_name} has been removed.
Your chairperson account ({chairperson_user.username}) has been deactivated.

You can continue to use your faculty account ({teacher_user.username}) for faculty-related activities.
        """
        
        # Send notification to the teacher's faculty account
        Notification.objects.create(
            user=teacher_user,
            title=f"Chairperson Role Removed - {department_name}",
            message=notification_message,
            notification_type='removal'
        )
        
        # Send email notification to faculty email
        try:
            send_mail(
                f"Chairperson Role Removed - {department_name}",
                notification_message,
                settings.DEFAULT_FROM_EMAIL,
                [teacher_user.email],
                fail_silently=False,
            )
        except Exception as e:
            print(f"Error sending email: {str(e)}")
            # Continue even if email fails
        
        # Delete the chairperson user account
        chairperson_user.delete()  # This will cascade delete the Chairperson record due to OneToOneField
        
        messages.success(request, f"Chairperson role has been removed from {teacher_user.get_full_name()}")
    except Chairperson.DoesNotExist:
        messages.error(request, "Chairperson record not found.")
    except Exception as e:
        messages.error(request, f"Error removing chairperson: {str(e)}")
    
    return redirect('manage_chairpersons')

@login_required
@user_passes_test(lambda u: u.is_superuser)
def assign_chairperson(request):
    if request.method == 'POST':
        department_id = request.POST.get('department')
        teacher_id = request.POST.get('teacher')
        
        try:
            department = Department.objects.get(id=department_id)
            faculty_user = CustomUser.objects.get(id=teacher_id, role='faculty')
            
            # Check if department already has a chairperson
            if Chairperson.objects.filter(department=department).exists():
                messages.error(request, f"Department {department.name} already has a chairperson.")
                return redirect('manage_chairpersons')
            
            # Check if teacher is already a chairperson
            if Chairperson.objects.filter(user=faculty_user).exists():
                messages.error(request, f"{faculty_user.get_full_name()} is already a chairperson of another department.")
                return redirect('manage_chairpersons')
            
            # Get the teacher's teacher code
            teacher_profile = Teacher.objects.get(user=faculty_user)
            
            # Create a unique username for chairperson
            base_username = faculty_user.username
            chairperson_username = f"{base_username}_chairperson"
            counter = 1
            while CustomUser.objects.filter(username=chairperson_username).exists():
                chairperson_username = f"{base_username}_chairperson_{counter}"
                counter += 1
            
            # Create a new user for chairperson role
            chairperson_user = CustomUser.objects.create(
                username=chairperson_username,
                email=faculty_user.email,
                password=faculty_user.password,  # This will be hashed
                first_name=faculty_user.first_name,
                last_name=faculty_user.last_name,
                role='chairperson'
            )
            
            # Create chairperson record
            chairperson = Chairperson.objects.create(
                user=chairperson_user,
                department=department,
                teacher_code=teacher_profile.teacher_code,
                is_approved=True  # Auto-approve when assigned by admin
            )
            
            messages.success(request, f"{faculty_user.get_full_name()} has been assigned as chairperson of {department.name} with a separate chairperson account.")
        except Teacher.DoesNotExist:
            messages.error(request, "Teacher profile not found.")
        except Exception as e:
            messages.error(request, f"Error assigning chairperson: {str(e)}")
    
    return redirect('manage_chairpersons')

@login_required
@user_passes_test(lambda u: u.is_superuser)
def edit_chairperson(request, chairperson_id):
    chairperson = get_object_or_404(Chairperson, id=chairperson_id)
    
    if request.method == 'POST':
        department_id = request.POST.get('department')
        teacher_id = request.POST.get('teacher')
        
        try:
            department = Department.objects.get(id=department_id)
            teacher = CustomUser.objects.get(id=teacher_id, role='faculty')
            
            # Check if department already has a chairperson (excluding current)
            if Chairperson.objects.filter(department=department).exclude(id=chairperson_id).exists():
                messages.error(request, f"Department {department.name} already has a chairperson.")
                return redirect('manage_chairpersons')
            
            # Update chairperson record
            chairperson.department = department
            chairperson.user = teacher
            chairperson.save()
            
            # Update teacher's role
            teacher.role = 'chairperson'
            teacher.save()
            
            messages.success(request, f"Chairperson assignment updated successfully.")
        except Exception as e:
            messages.error(request, f"Error updating chairperson: {str(e)}")
    
    return redirect('manage_chairpersons')

@login_required
@user_passes_test(lambda u: u.is_superuser)
def remove_chairperson(request, chairperson_id):
    try:
        chairperson = Chairperson.objects.select_related('user', 'department').get(id=chairperson_id)
        department_name = chairperson.department.name
        chairperson_user = chairperson.user
        
        # Get the original teacher user
        teacher_user = CustomUser.objects.get(
            username=chairperson_user.username.replace('_chairperson', ''),
            role='faculty'
        )
        
        # Create removal notification message
        notification_message = f"""
Your chairperson role for {department_name} has been removed.
Your chairperson account ({chairperson_user.username}) has been deactivated.

You can continue to use your faculty account ({teacher_user.username}) for faculty-related activities.
        """
        
        # Send notification to the teacher's faculty account
        Notification.objects.create(
            user=teacher_user,
            title=f"Chairperson Role Removed - {department_name}",
            message=notification_message,
            notification_type='removal'
        )
        
        # Send email notification to faculty email
        try:
            send_mail(
                f"Chairperson Role Removed - {department_name}",
                notification_message,
                settings.DEFAULT_FROM_EMAIL,
                [teacher_user.email],
                fail_silently=False,
            )
        except Exception as e:
            print(f"Error sending email: {str(e)}")
            # Continue even if email fails
        
        # Delete the chairperson user account
        chairperson_user.delete()  # This will cascade delete the Chairperson record due to OneToOneField
        
        messages.success(request, f"Chairperson role has been removed from {teacher_user.get_full_name()}")
    except Chairperson.DoesNotExist:
        messages.error(request, "Chairperson record not found.")
    except Exception as e:
        messages.error(request, f"Error removing chairperson: {str(e)}")
    
    return redirect('manage_chairpersons')

@login_required
def get_teachers_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching teachers for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get all teachers from the department who are not already deans
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=department_id
        ).exclude(
            dean__isnull=False  # Exclude teachers who are already deans
        ).select_related('teacher').values('id', 'first_name', 'last_name', 'email')
        
        # Format the response
        teachers_list = [
            {
                'id': teacher['id'],
                'name': teacher['first_name'] + ' ' + teacher['last_name'],
                'email': teacher['email']
            }
            for teacher in teachers
        ]
        
        return JsonResponse({'teachers': teachers_list})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@user_passes_test(lambda u: u.is_superuser)
def approve_chairperson(request, chairperson_id):
    try:
        chairperson = Chairperson.objects.get(id=chairperson_id)
        chairperson.is_approved = True
        chairperson.updated_at = timezone.now()
        chairperson.save()
        
        messages.success(request, f'Chairperson {chairperson.user.get_full_name()} has been approved successfully.')
    except Chairperson.DoesNotExist:
        messages.error(request, 'Chairperson not found.')
    
    return redirect('manage_chairpersons')

@login_required
@user_passes_test(lambda u: u.is_superuser)
def reject_chairperson(request, chairperson_id):
    try:
        chairperson = Chairperson.objects.get(id=chairperson_id)
        user = chairperson.user
        chairperson.delete()
        user.delete()
        
        messages.success(request, 'Chairperson has been removed successfully.')
    except Chairperson.DoesNotExist:
        messages.error(request, 'Chairperson not found.')
    
    return redirect('manage_chairpersons')

@login_required
@user_passes_test(lambda u: u.is_superuser)
def manage_courses(request):
    departments = Department.objects.all()
    courses = Course.objects.all().select_related('department', 'program', 'semester')
    
    # Handle filtering
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    
    if department_id:
        courses = courses.filter(department_id=department_id)
    if program_id:
        courses = courses.filter(program_id=program_id)
    if semester_id:
        courses = courses.filter(semester_id=semester_id)
    
    return render(request, 'attendance/manage_courses.html', {
        'departments': departments,
        'courses': courses
    })

@login_required
@user_passes_test(lambda u: u.is_superuser)
def add_course(request):
    if request.method == 'POST':
        try:
            department_id = request.POST.get('department')
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_code = request.POST.get('course_code')
            course_name = request.POST.get('course_name')
            course_credit = request.POST.get('course_credit')
            
            if not all([department_id, program_id, semester_id, course_code, course_name, course_credit]):
                messages.error(request, 'All fields are required.')
                return redirect('add_course')
            
            if Course.objects.filter(code=course_code).exists():
                messages.error(request, 'A course with this code already exists.')
                return redirect('add_course')
            
            course = Course.objects.create(
                department_id=department_id,
                program_id=program_id,
                semester_id=semester_id,
                code=course_code,
                name=course_name,
                credit=course_credit
            )
            
            messages.success(request, f'Course "{course.name}" has been added successfully!')
            return redirect('manage_courses')
            
        except Exception as e:
            messages.error(request, f'Error adding course: {str(e)}')
            return redirect('add_course')
    
    departments = Department.objects.all()
    return render(request, 'attendance/admin_authentication_template/add_course.html', {
        'departments': departments
    })

@login_required
@user_passes_test(lambda u: u.is_superuser)
def edit_course(request, course_id):
    course = get_object_or_404(Course, id=course_id)
    departments = Department.objects.all()

    if request.method == 'POST':
        try:
            course.department_id = request.POST['department']
            course.program_id = request.POST['program']
            course.semester_id = request.POST['semester']
            course.code = request.POST['course_code']
            course.name = request.POST['course_name']
            course.credit = request.POST['course_credit']
            course.save()
            messages.success(request, f'Course "{course.name}" has been updated successfully!')
            return redirect('manage_courses')
        except Exception as e:
            messages.error(request, f'Error updating course: {str(e)}')
            return redirect('edit_course', course_id=course_id)

    context = {
        'course': course,
        'departments': departments,
    }
    return render(request, 'attendance/manage_course_template/edit_course.html', context)

@login_required
@user_passes_test(lambda u: u.is_superuser)
def delete_course(request, course_id):
    """View to delete a course."""
    try:
        course = get_object_or_404(Course, id=course_id)
        course_name = course.name
        course.delete()
        messages.success(request, f'Course "{course_name}" has been deleted successfully!')
    except Exception as e:
        messages.error(request, f'Error deleting course: {str(e)}')
    return redirect("manage_courses")

@login_required
@chairperson_required
def chairperson_manage_programs(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get all programs for this department
    programs = Program.objects.select_related('department').filter(department=department)

    if request.method == "POST":
        try:
            # Department is fixed to chairperson's department
            program_name = request.POST.get("program_name")
            duration = int(request.POST.get("duration"))  # Convert to int safely
            num_semesters = int(request.POST.get("num_semesters"))  # Convert to int safely

            program = Program.objects.create(
                department=department, 
                name=program_name, 
                duration=duration, 
                num_semesters=num_semesters
            )

            # Prevent duplicate semesters
            for i in range(1, num_semesters + 1):
                semester_name = "Semester " + str(i)  # Explicitly convert i to str
                if not Semester.objects.filter(program=program, name=semester_name).exists():
                    Semester.objects.create(program=program, name=semester_name)

            messages.success(request, "Program and semesters added successfully!")

        except IntegrityError:
            messages.error(request, "A program with the same name or semester name already exists in this department.")
        except ValueError:
            messages.error(request, "Invalid input: Duration and number of semesters must be numbers.")
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")

    return render(request, "attendance/chairperson_authentication_template/manage_programs.html", {
        "chairperson": chairperson,
        "department": department,
        "programs": programs
    })

@login_required
@chairperson_required
def chairperson_manage_semesters(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get all programs for this department
    programs = Program.objects.filter(department=department)
    
    # Get all semesters for this department's programs
    semesters = Semester.objects.filter(program__department=department)
    
    # Get filter parameters
    program_id = request.GET.get('program')
    
    # Filter semesters by program if selected
    if program_id:
        semesters = semesters.filter(program_id=program_id)
    
    if request.method == "POST":
        try:
            program_id = request.POST.get("program")
            semester_name = request.POST.get("semester_name")
            
            if not program_id or not semester_name:
                messages.error(request, "Program and semester name are required.")
                return redirect('chairperson_manage_semesters')
            
            # Ensure program belongs to chairperson's department
            program = Program.objects.get(id=program_id, department=department)
            
            # Check if semester already exists for this program
            if Semester.objects.filter(program=program, name=semester_name).exists():
                messages.error(request, "A semester with this name already exists in this program.")
                return redirect('chairperson_manage_semesters')
            
            # Create new semester
            Semester.objects.create(program=program, name=semester_name)
            messages.success(request, f"Semester '{semester_name}' added successfully to {program.name}!")
            
        except Program.DoesNotExist:
            messages.error(request, "Selected program does not exist or you don't have access to it.")
        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
    
    context = {
        'departments': [department],  # Only show chairperson's department
        'programs': programs,
        'semesters': semesters,
        'selected_program': program_id,
    }
    
    return render(request, "attendance/manage_semester_template/manage_semesters.html", context)

@login_required
@chairperson_required
def chairperson_attendance_summary(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get programs for the chairperson's department
    programs = Program.objects.filter(department=department)
    semesters = Semester.objects.none()
    courses = Course.objects.none()
    
    # Get filter parameters
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    selected_courses = request.GET.getlist('courses')
    
    # Convert selected_courses to integers and filter out invalid values
    try:
        selected_courses = [int(course_id) for course_id in selected_courses if course_id and course_id.isdigit()]
    except (ValueError, TypeError):
        selected_courses = []
    
    # Get semesters based on selected program
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id)
    
    # Get courses based on selected semester
    if semester_id:
        courses = Course.objects.filter(semester_id=semester_id)
    
    # Initialize context
    context = {
        'department': department,
        'programs': programs,
        'semesters': semesters,
        'courses': courses,
        'selected_program': program_id,
        'selected_semester': semester_id,
        'selected_courses': selected_courses,
        'from_date': from_date,
        'to_date': to_date
    }
    
    # If filters are applied
    if program_id and semester_id and from_date and to_date:
        try:
            program = Program.objects.get(id=program_id, department=department)
            semester = Semester.objects.get(id=semester_id, program=program)
            
            # Get courses based on filter
            if selected_courses:
                courses = Course.objects.filter(id__in=selected_courses, semester=semester)
            else:
                courses = Course.objects.filter(semester=semester)
            
            # Calculate total classes for each course
            for course in courses:
                # Get all attendance records for this course
                attendance_records = Attendance.objects.filter(
                    course=course,
                    date__range=[from_date, to_date]
                )
                
                # Count how many times each student name appears
                student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
                
                # Get the maximum count (this will be the total classes for this course)
                course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            
            # Get all enrolled students for the program and semester
            enroll_students = EnrollStudent.objects.filter(
                program=program,
                semester=semester
            ).select_related('user')
            
            students = []
            for enroll_student in enroll_students:
                try:
                    # Get the Student model instance using the enrollment number
                    student = Student.objects.get(
                        enrollment_no=enroll_student.user.username,
                        program=program,
                        semester=semester
                    )
                    
                    student_info = {
                        'name': student.name,
                        'courses': [],
                        'total_classes': 0,
                        'total_present': 0,
                        'overall_percentage': 0
                    }
                    
                    for course in courses:
                        # Get attendance records for this student and course
                        attendance_records = Attendance.objects.filter(
                            student=student,
                            course=course,
                            date__range=[from_date, to_date]
                        )
                        
                        # Count total classes and present count for this student and course
                        total_classes = attendance_records.count()
                        present_count = attendance_records.filter(status='Present').count()
                        percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                        
                        student_info['courses'].append({
                            'name': course.name,
                            'total_classes': total_classes,
                            'present_count': present_count,
                            'percentage': percentage
                        })
                        
                        student_info['total_classes'] += total_classes
                        student_info['total_present'] += present_count
                    
                    if student_info['total_classes'] > 0:
                        student_info['overall_percentage'] = round(
                            (student_info['total_present'] / student_info['total_classes'] * 100), 2
                        )
                    
                    students.append(student_info)
                except Student.DoesNotExist:
                    # Skip students that don't have a corresponding Student record
                    continue
            
            # Calculate total classes across all courses
            total_classes = sum(course.total_classes for course in courses)
            
            context.update({
                'program': program,
                'semester': semester,
                'courses': courses,
                'students': students,
                'total_classes': total_classes,
                'has_data': True  # Add flag to indicate data is available
            })
            
        except (Program.DoesNotExist, Semester.DoesNotExist) as e:
            messages.error(request, str(e))
    
    return render(request, 'attendance/chairperson_authentication_template/attendance_summary.html', context)

@login_required
@chairperson_required
def chairperson_attendance_report(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get filter parameters
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    
    # Get programs for the chairperson's department
    programs = Program.objects.filter(department=department)
    
    # Get semesters based on selected program
    semesters = Semester.objects.none()
    if program_id:
        semesters = Semester.objects.filter(program_id=program_id)
    
    # Initialize context
    context = {
        'department': department,
        'programs': programs,
        'semesters': semesters,
        'selected_program': program_id,
        'selected_semester': semester_id,
        'from_date': from_date,
        'to_date': to_date
    }
    
    # If filters are applied
    if program_id and semester_id and from_date and to_date:
        try:
            program = Program.objects.get(id=program_id, department=department)
            semester = Semester.objects.get(id=semester_id, program=program)
            
            # Get all courses for the semester
            courses = Course.objects.filter(semester=semester)
            
            # Calculate total classes for each course
            for course in courses:
                # Get all attendance records for this course
                attendance_records = Attendance.objects.filter(
                    course=course,
                    date__range=[from_date, to_date]
                )
                
                # Count how many times each student name appears
                student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
                
                # Get the maximum count (this will be the total classes for this course)
                course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            
            # Get all enrolled students for the program and semester
            enroll_students = EnrollStudent.objects.filter(
                program=program,
                semester=semester
            ).select_related('user')
            
            students = []
            for enroll_student in enroll_students:
                student = enroll_student.user
                student_info = {
                    'name': student.name,
                    'courses': [],
                    'total_classes': 0,
                    'total_present': 0,
                    'overall_percentage': 0
                }
                
                for course in courses:
                    # Get attendance records for this student and course
                    attendance_records = Attendance.objects.filter(
                        student__first_name=student.first_name,
                        student__last_name=student.last_name,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    attendance_records = Attendance.objects.filter(
                        student__first_name=student.first_name,
                        student__last_name=student.last_name,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    # Count total classes and present count for this student and course
                    total_classes = attendance_records.count()
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    student_info['courses'].append({
                        'name': course.name,
                        'total_classes': total_classes,
                        'present_count': present_count,
                        'percentage': percentage
                    })
                    
                    student_info['total_classes'] += total_classes
                    student_info['total_present'] += present_count
                
                if student_info['total_classes'] > 0:
                    student_info['overall_percentage'] = round(
                        (student_info['total_present'] / student_info['total_classes'] * 100), 2
                    )
                
                students.append(student_info)
            
            # Calculate total classes across all courses
            total_classes = sum(course.total_classes for course in courses)
            
            context.update({
                'program': program,
                'semester': semester,
                'courses': courses,
                'students': students,
                'total_classes': total_classes
            })
            
        except Exception as e:
            messages.error(request, f"Error generating report: {str(e)}")
    
    return render(request, 'attendance/chairperson_authentication_template/attendance_report.html', context)

@login_required
@chairperson_required
def chairperson_export_attendance(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get filter parameters
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    export_format = request.GET.get('format', 'csv')  # Default to CSV
    
    if not all([program_id, semester_id, from_date, to_date]):
        messages.error(request, "All filter parameters are required for export")
        return redirect('chairperson_attendance_report')
    
    try:
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get all courses for the semester
        courses = Course.objects.filter(semester=semester)
        
        # Calculate total classes for each course
        for course in courses:
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            student_counts = attendance_records.values('student__first_name', 'student__last_name').annotate(count=Count('id'))
            course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Calculate total classes across all courses
        total_classes_all = sum(course.total_classes for course in courses)
        
        if export_format == 'csv':
            # Create CSV response
            response = HttpResponse(content_type='text/csv')
            response['Content-Disposition'] = f'attachment; filename="attendance_report_{from_date}_to_{to_date}.csv"'
            
            writer = csv.writer(response)
            
            # Write filter information
            writer.writerow(['Attendance Report'])
            writer.writerow(['Department:', department.name])
            writer.writerow(['Program:', program.name])
            writer.writerow(['Semester:', semester.name])
            writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
            writer.writerow([])  # Empty row for spacing
            
            # Write header row
            header = ['Sr. No.', 'Student Name']
            for course in courses:
                header.extend([
                    f'{course.code} - Present out of {course.total_classes}',
                    f'{course.code} - %'
                ])
            header.extend([f'Total Present out of {total_classes_all}', 'Overall %'])
            writer.writerow(header)
            
            # Write data rows
            for index, enroll_student in enumerate(enroll_students, 1):
                student = enroll_student.user
                student_name = f"{student.first_name} {student.last_name}"
                row = [index, student_name]
                
                total_present = 0
                total_classes = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student__first_name=student.first_name,
                        student__last_name=student.last_name,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    course_total = attendance_records.count()
                    course_present = attendance_records.filter(status='Present').count()
                    percentage = round((course_present / course_total * 100) if course_total > 0 else 0, 2)
                    
                    row.extend([course_present, f'{percentage}%'])
                    total_present += course_present
                    total_classes += course_total
                
                overall_percentage = round((total_present / total_classes * 100) if total_classes > 0 else 0, 2)
                row.extend([str(total_present), f'{overall_percentage}%'])
                
                writer.writerow(row)
            
            return response
            
        elif export_format == 'pdf':
            # Create PDF response
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="attendance_report_{from_date}_to_{to_date}.pdf"'
            
            buffer = BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=landscape(letter))
            elements = []
            
            # Define styles
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Title'],
                fontSize=14,
                spaceAfter=12,
                alignment=1
            )
            normal_style = ParagraphStyle(
                'CustomNormal',
                parent=styles['Normal'],
                fontSize=7,
                spaceAfter=6,
                wordWrap='CJK'  # Enable word wrapping
            )
            
            # Add title and filter details
            elements.append(Paragraph('Attendance Report', title_style))
            
            # Create a table for filter details
            filter_data = [
                ['Department:', department.name, 'Program:', program.name],
                ['Semester:', semester.name, 'Date Range:', f'{from_date} to {to_date}']
            ]
            
            filter_table = Table(filter_data, colWidths=[1.2*inch, 1.8*inch, 1.2*inch, 1.8*inch])
            filter_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 7),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(filter_table)
            elements.append(Spacer(1, 12))
            
            # Create table data with wrapped text for headers
            table_data = [['Sr. No.', 'Student Name']]
            for course in courses:
                course_info = f'{course.code}\nPresent out of {course.total_classes}'
                table_data[0].extend([course_info, '%'])
            table_data[0].extend([f'Total Present\nout of {total_classes_all}', 'Overall %'])
            
            # Process data
            for index, enroll_student in enumerate(enroll_students, 1):
                student = enroll_student.user
                student_name = f"{student.first_name} {student.last_name}"
                if len(student_name) > 15:  # Limit student name length
                    student_name = student_name[:15] + '...'
                
                row = [str(index), student_name]
                total_present = 0
                total_classes = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student__first_name=student.first_name,
                        student__last_name=student.last_name,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    course_total = attendance_records.count()
                    course_present = attendance_records.filter(status='Present').count()
                    percentage = round((course_present / course_total * 100) if course_total > 0 else 0, 2)
                    row.extend([str(course_present), f'{percentage}%'])
                    total_present += course_present
                    total_classes += course_total
                
                overall_percentage = round((total_present / total_classes * 100) if total_classes > 0 else 0, 2)
                row.extend([str(total_present), f'{overall_percentage}%'])
                
                table_data.append(row)
                row_number += 1
            
            # Split columns into two parts for better PDF layout
            num_columns = len(table_data[0])
            mid_column = (num_columns - 2) // 2  # Exclude Sr. No. and Student Name columns
            
            # First page columns
            table_data_page1 = []
            for row in table_data:
                table_data_page1.append(row[:mid_column + 2])  # Include Sr. No. and Student Name columns
            
            # Second page columns
            table_data_page2 = []
            for row in table_data:
                table_data_page2.append([row[0], row[1]] + row[mid_column + 2:])  # Include Sr. No. and Student Name columns
            
            # Calculate optimized column widths for first page
            col_widths_page1 = [0.25*inch]  # Sr. No. column
            col_widths_page1.append(0.7*inch)  # Student Name column
            for _ in range((mid_column) // 2):
                col_widths_page1.extend([0.8*inch, 0.3*inch])  # Course columns
            
            # Create first table
            table1 = Table(table_data_page1, colWidths=col_widths_page1)
            table1.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 7),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 30),
                ('TOPPADDING', (0, 0), (-1, 0), 30),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 7),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
                ('WORDWRAP', (0, 0), (-1, -1), True),
                ('MINIMUMHEIGHT', (0, 0), (-1, 0), 1.5*inch),
                ('LEADING', (0, 0), (-1, 0), 8),  # Reduced line spacing for header row
            ]))
            
            elements.append(table1)
            elements.append(PageBreak())
            
            # Calculate optimized column widths for second page
            col_widths_page2 = [0.25*inch]  # Sr. No. column
            col_widths_page2.append(0.7*inch)  # Student Name column
            for _ in range((num_columns - mid_column - 2) // 2):
                col_widths_page2.extend([0.8*inch, 0.3*inch])  # Course columns
            
            # Create second table
            table2 = Table(table_data_page2, colWidths=col_widths_page2)
            table2.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 7),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 30),
                ('TOPPADDING', (0, 0), (-1, 0), 30),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 7),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
                ('WORDWRAP', (0, 0), (-1, -1), True),
                ('MINIMUMHEIGHT', (0, 0), (-1, 0), 1.5*inch),
                ('LEADING', (0, 0), (-1, 0), 8),  # Reduced line spacing for header row
            ]))
            
            elements.append(table2)
            
            # Build PDF
            doc.build(elements)
            
            pdf = buffer.getvalue()
            buffer.close()
            response.write(pdf)
            return response
            
        else:
            messages.error(request, f"Unsupported export format: {export_format}")
            return redirect('chairperson_attendance_report')
            
    except Exception as e:
        messages.error(request, f"Error generating export: {str(e)}")
        return redirect('chairperson_attendance_report')

@login_required
@chairperson_required
def chairperson_add_program(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    if request.method == 'POST':
        program_name = request.POST.get('program_name')
        program_code = request.POST.get('program_code')
        program_description = request.POST.get('program_description')
        
        # Validate required fields
        if not all([program_name, program_code]):
            messages.error(request, "Program name and code are required")
            return redirect('chairperson_manage_programs')
        
        try:
            # Check if program code already exists
            if Program.objects.filter(code=program_code).exists():
                messages.error(request, "A program with this code already exists")
                return redirect('chairperson_manage_programs')
            
            # Create new program
            program = Program.objects.create(
                name=program_name,
                code=program_code,
                description=program_description,
                department=department
            )
            
            # Create default semesters for the program
            for semester_num in range(1, 9):  # Create 8 semesters
                Semester.objects.create(
                    name=f"Semester {semester_num}",
                    program=program
                )
            
            messages.success(request, f"Program '{program_name}' created successfully with 8 semesters")
            return redirect('chairperson_manage_programs')
            
        except Exception as e:
            messages.error(request, f"Error creating program: {str(e)}")
            return redirect('chairperson_manage_programs')
    
    # If GET request, render the form
    return render(request, 'attendance/chairperson_authentication_template/add_program.html', {
        'department': department
    })

@login_required
@chairperson_required
def chairperson_edit_program(request, program_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        program = Program.objects.get(id=program_id, department=department)
    except Program.DoesNotExist:
        messages.error(request, "Program not found or you don't have permission to edit it.")
        return redirect('chairperson_manage_programs')
    
    if request.method == 'POST':
        program_name = request.POST.get('program_name')
        duration = request.POST.get('duration')
        num_semesters = request.POST.get('num_semesters')
        
        # Validate required fields
        if not all([program_name, duration, num_semesters]):
            messages.error(request, "All fields are required")
            return redirect('chairperson_edit_program', program_id=program_id)
        
        try:
            # Convert to integers
            duration = int(duration)
            num_semesters = int(num_semesters)
            
            # Validate values
            if duration < 1 or duration > 6:
                messages.error(request, "Duration must be between 1 and 6 years")
                return redirect('chairperson_edit_program', program_id=program_id)
            
            if num_semesters < 1 or num_semesters > 12:
                messages.error(request, "Number of semesters must be between 1 and 12")
                return redirect('chairperson_edit_program', program_id=program_id)
            
            # Update program
            program.name = program_name
            program.duration = duration
            program.num_semesters = num_semesters
            program.save()
            
            messages.success(request, f"Program '{program_name}' updated successfully")
            return redirect('chairperson_manage_programs')
            
        except ValueError:
            messages.error(request, "Duration and number of semesters must be numbers")
            return redirect('chairperson_edit_program', program_id=program_id)
        except Exception as e:
            messages.error(request, f"Error updating program: {str(e)}")
            return redirect('chairperson_edit_program', program_id=program_id)
    
    # If GET request, render the form with current program data
    return render(request, 'attendance/chairperson_authentication_template/edit_program.html', {
        'program': program,
        'department': department
    })

@login_required
@chairperson_required
def chairperson_delete_program(request, program_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        program = Program.objects.get(id=program_id, department=department)
        
        # Check if program has any courses
        if Course.objects.filter(program=program).exists():
            messages.error(request, "Cannot delete program because it has courses. Please delete all courses first.")
            return redirect('chairperson_manage_programs')
        
        # Delete program (this will cascade delete semesters)
        program_name = program.name
        program.delete()
        
        messages.success(request, f"Program '{program_name}' deleted successfully")
        
    except Program.DoesNotExist:
        messages.error(request, "Program not found or you don't have permission to delete it.")
    except Exception as e:
        messages.error(request, f"Error deleting program: {str(e)}")
    
    return redirect('chairperson_manage_programs')

@login_required
@chairperson_required
def chairperson_add_course(request):
    if not hasattr(request.user, 'chairperson'):
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('login')
    
    chairperson = request.user.chairperson
    department = chairperson.department
    
    if request.method == 'POST':
        try:
            program_id = request.POST.get('program')
            semester_id = request.POST.get('semester')
            course_code = request.POST.get('course_code')
            course_name = request.POST.get('course_name')
            course_credit = request.POST.get('course_credit')
            
            # Validate inputs
            if not all([program_id, semester_id, course_code, course_name, course_credit]):
                messages.error(request, 'All fields are required.')
                return redirect('chairperson_manage_courses')
            
            # Check if program belongs to chairperson's department
            program = Program.objects.get(id=program_id)
            if program.department != department:
                messages.error(request, 'Invalid program selected.')
                return redirect('chairperson_manage_courses')
            
            # Check if semester belongs to the selected program
            semester = Semester.objects.get(id=semester_id)
            if semester.program != program:
                messages.error(request, 'Invalid semester selected.')
                return redirect('chairperson_manage_courses')
            
            # Check if course code already exists
            if Course.objects.filter(code=course_code).exists():
                messages.error(request, 'Course code already exists.')
                return redirect('chairperson_manage_courses')
            
            # Create new course
            course = Course.objects.create(
                code=course_code,
                name=course_name,
                credit=course_credit,
                department=department,
                program=program,
                semester=semester
            )
            
            messages.success(request, f'Course {course.name} added successfully.')
            return redirect('chairperson_manage_courses')
            
        except (Program.DoesNotExist, Semester.DoesNotExist):
            messages.error(request, 'Invalid program or semester selected.')
            return redirect('chairperson_manage_courses')
        except Exception as e:
            messages.error(request, f'Error adding course: {str(e)}')
            return redirect('chairperson_manage_courses')
    
    return redirect('chairperson_manage_courses')

@login_required
@chairperson_required
def chairperson_edit_course(request, course_id):
    if not hasattr(request.user, 'chairperson'):
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('login')
    
    chairperson = request.user.chairperson
    department = chairperson.department
    
    try:
        course = Course.objects.get(id=course_id)
        
        # Check if course belongs to chairperson's department
        if course.department != department:
            messages.error(request, 'You do not have permission to edit this course.')
            return redirect('chairperson_manage_courses')
        
        if request.method == 'POST':
            try:
                program_id = request.POST.get('program')
                semester_id = request.POST.get('semester')
                course_code = request.POST.get('course_code')
                course_name = request.POST.get('course_name')
                course_credit = request.POST.get('course_credit')
                
                # Validate inputs
                if not all([program_id, semester_id, course_code, course_name, course_credit]):
                    messages.error(request, 'All fields are required.')
                    return redirect('chairperson_edit_course', course_id=course_id)
                
                # Check if program belongs to chairperson's department
                program = Program.objects.get(id=program_id)
                if program.department != department:
                    messages.error(request, 'Invalid program selected.')
                    return redirect('chairperson_edit_course', course_id=course_id)
                
                # Check if semester belongs to the selected program
                semester = Semester.objects.get(id=semester_id)
                if semester.program != program:
                    messages.error(request, 'Invalid semester selected.')
                    return redirect('chairperson_edit_course', course_id=course_id)
                
                # Check if course code already exists (excluding current course)
                if Course.objects.exclude(id=course_id).filter(code=course_code).exists():
                    messages.error(request, 'Course code already exists.')
                    return redirect('chairperson_edit_course', course_id=course_id)
                
                # Update course
                course.code = course_code
                course.name = course_name
                course.credit = course_credit
                course.program = program
                course.semester = semester
                course.save()
                
                messages.success(request, f'Course {course.name} updated successfully.')
                return redirect('chairperson_manage_courses')
                
            except (Program.DoesNotExist, Semester.DoesNotExist):
                messages.error(request, 'Invalid program or semester selected.')
                return redirect('chairperson_edit_course', course_id=course_id)
            except Exception as e:
                messages.error(request, f'Error updating course: {str(e)}')
                return redirect('chairperson_edit_course', course_id=course_id)
        
        # Get programs and semesters for the form
        programs = Program.objects.filter(department=department)
        semesters = Semester.objects.filter(program=course.program)
        
        context = {
            'course': course,
            'department': department,
            'programs': programs,
            'semesters': semesters,
        }
        
        return render(request, 'attendance/chairperson_authentication_template/edit_course.html', context)
        
    except Course.DoesNotExist:
        messages.error(request, 'Course not found.')
        return redirect('chairperson_manage_courses')

@login_required
@chairperson_required
def chairperson_delete_course(request, course_id):
    if not hasattr(request.user, 'chairperson'):
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('login')
    
    chairperson = request.user.chairperson
    department = chairperson.department
    
    try:
        course = Course.objects.get(id=course_id)
        
        # Check if course belongs to chairperson's department
        if course.department != department:
            messages.error(request, 'You do not have permission to delete this course.')
            return redirect('chairperson_manage_courses')
        
        if request.method == 'POST':
            course_name = course.name
            course.delete()
            messages.success(request, f'Course {course_name} deleted successfully.')
        
        return redirect('chairperson_manage_courses')
        
    except Course.DoesNotExist:
        messages.error(request, 'Course not found.')
        return redirect('chairperson_manage_courses')

@login_required
@chairperson_required
def chairperson_export_attendance_csv(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get filter parameters
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    selected_courses = request.GET.getlist('courses')
    
    # Convert selected_courses to integers and filter out invalid values
    try:
        selected_courses = [int(course_id) for course_id in selected_courses if course_id and course_id.isdigit()]
    except (ValueError, TypeError):
        selected_courses = []
    
    try:
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get courses based on filter
        if selected_courses:
            courses = Course.objects.filter(id__in=selected_courses, semester=semester)
        else:
            courses = Course.objects.filter(semester=semester)
        
        # Create the HttpResponse object with the appropriate CSV header
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="attendance_summary_{program.name}_{semester.name}_{from_date}_to_{to_date}.csv"'
        
        # Create CSV writer
        writer = csv.writer(response)
        
        # Calculate total classes across all courses
        total_classes_all = 0
        course_total_classes = {}
        for course in courses:
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
            total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            course_total_classes[course.id] = total_classes
            total_classes_all += total_classes
        
        # Write header rows
        header1 = ['Sr. No.', 'Student Name']
        header2 = ['', '']
        
        for course in courses:
            total_classes = course_total_classes[course.id]
            header1.extend([course.code, ''])
            header2.extend([f'Total Classes: {total_classes}', ''])
        
        header1.extend(['Total Present', 'Overall %'])
        header2.extend([f'Total Classes: {total_classes_all}', ''])
        
        writer.writerow(header1)
        writer.writerow(header2)
        
        # Write subheader row
        subheader = ['', '']
        for course in courses:
            subheader.extend(['Present', '%'])
        subheader.extend(['', ''])
        writer.writerow(subheader)
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Write data rows
        row_number = 1
        for enroll_student in enroll_students:
            try:
                student = Student.objects.get(
                    enrollment_no=enroll_student.user.username,
                    program=program,
                    semester=semester
                )
                
                row = [str(row_number), student.name]
                total_present = 0
                total_classes_attended = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student=student,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    total_classes = course_total_classes[course.id]
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    row.extend([str(present_count), f"{percentage}%"])
                    total_present += present_count
                    total_classes_attended += total_classes
                
                # Calculate overall percentage correctly
                overall_percentage = round((total_present / total_classes_attended * 100) if total_classes_attended > 0 else 0, 2)
                row.extend([str(total_present), f"{overall_percentage}%"])
                
                writer.writerow(row)
                row_number += 1
            except Student.DoesNotExist:
                continue
        
        return response
        
    except (Program.DoesNotExist, Semester.DoesNotExist) as e:
        messages.error(request, str(e))
        return redirect('chairperson_attendance_summary')

@login_required
@chairperson_required
def chairperson_export_attendance_pdf(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    # Get filter parameters
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    selected_courses = request.GET.getlist('courses')
    
    # Convert selected_courses to integers and filter out invalid values
    try:
        selected_courses = [int(course_id) for course_id in selected_courses if course_id and course_id.isdigit()]
    except (ValueError, TypeError):
        selected_courses = []
    
    try:
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get courses based on filter
        if selected_courses:
            courses = Course.objects.filter(id__in=selected_courses, semester=semester)
        else:
            courses = Course.objects.filter(semester=semester)
        
        # Create the HttpResponse object with the appropriate PDF header
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="attendance_summary_{program.name}_{semester.name}_{from_date}_to_{to_date}.pdf"'
        
        # Calculate page size based on number of courses
        num_courses = len(courses)
        if num_courses <= 2:
            page_size = letter
        elif num_courses <= 4:
            page_size = landscape(letter)
        else:
            # For more than 4 courses, use a custom size
            page_size = landscape((11 * inch, 17 * inch))  # Wider page for more courses
        
        # Create PDF document
        doc = SimpleDocTemplate(response, pagesize=page_size)
        elements = []
        
        # Add title
        title = f"Attendance Summary - {program.name} - {semester.name}"
        elements.append(Paragraph(title, getSampleStyleSheet()['Title']))
        
        # Add filter details
        details = [
            f"Department: {department.name}",
            f"Program: {program.name}",
            f"Semester: {semester.name}",
            f"Date Range: {from_date} to {to_date}"
        ]
        for detail in details:
            elements.append(Paragraph(detail, getSampleStyleSheet()['Normal']))
        elements.append(Spacer(1, 20))
        
        # Calculate total classes across all courses
        total_classes_all = 0
        course_total_classes = {}
        for course in courses:
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
            total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            course_total_classes[course.id] = total_classes
            total_classes_all += total_classes
        
        # Create table data
        data = []
        
        # Add header rows
        header1 = ['Sr. No.', 'Student Name']
        header2 = ['', '']
        
        for course in courses:
            total_classes = course_total_classes[course.id]
            header1.extend([course.code, ''])
            header2.extend([f'Total Classes: {total_classes}', ''])
        
        header1.extend(['Total Present', 'Overall %'])
        header2.extend([f'Total Classes: {total_classes_all}', ''])
        
        data.append(header1)
        data.append(header2)
        
        # Add subheader row
        subheader = ['', '']
        for course in courses:
            subheader.extend(['Present', '%'])
        subheader.extend(['', ''])
        data.append(subheader)
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Add data rows
        row_number = 1
        for enroll_student in enroll_students:
            try:
                student = Student.objects.get(
                    enrollment_no=enroll_student.user.username,
                    program=program,
                    semester=semester
                )
                
                row = [str(row_number), student.name]
                total_present = 0
                total_classes_attended = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student=student,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    total_classes = course_total_classes[course.id]
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    row.extend([str(present_count), f"{percentage}%"])
                    total_present += present_count
                    total_classes_attended += total_classes
                
                # Calculate overall percentage correctly
                overall_percentage = round((total_present / total_classes_attended * 100) if total_classes_attended > 0 else 0, 2)
                row.extend([str(total_present), f"{overall_percentage}%"])
                
                data.append(row)
                row_number += 1
            except Student.DoesNotExist:
                continue
        
        # Calculate column widths based on number of courses and page size
        num_columns = 2 + (len(courses) * 2) + 2  # Sr. No., Name, (Present, %) for each course, Total, Overall %
        if num_courses <= 2:
            col_widths = [0.5*inch, 2*inch] + [1.2*inch, 1.2*inch] * len(courses) + [1.5*inch, 1*inch]
        elif num_courses <= 4:
            col_widths = [0.5*inch, 1.5*inch] + [1*inch, 1*inch] * len(courses) + [1.2*inch, 0.8*inch]
        else:
            col_widths = [0.5*inch, 1.2*inch] + [0.8*inch, 0.8*inch] * len(courses) + [1*inch, 0.7*inch]
        
        # Create table
        table = Table(data, colWidths=col_widths)
        
        # Add table style
        style = TableStyle([
            # Header styles
            ('BACKGROUND', (0, 0), (-1, 1), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 1), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 1), 12),
            ('BACKGROUND', (0, 2), (-1, 2), colors.lightgrey),
            ('TEXTCOLOR', (0, 2), (-1, 2), colors.black),
            ('FONTNAME', (0, 2), (-1, 2), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 2), (-1, 2), 10),
            ('BOTTOMPADDING', (0, 2), (-1, 2), 12),
            # Data styles
            ('FONTNAME', (0, 3), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 3), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6)
        ])
        table.setStyle(style)
        
        # Add table to elements
        elements.append(table)
        
        # Build PDF
        doc.build(elements)
        return response
        
    except (Program.DoesNotExist, Semester.DoesNotExist) as e:
        messages.error(request, str(e))
        return redirect('chairperson_attendance_summary')

def unified_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')  # This can be email or username
        password = request.POST.get('password')
        
        try:
            # Try to find user by email or username using filter().first()
            user = CustomUser.objects.filter(Q(email=username) | Q(username=username)).first()
            
            if user:
                authenticated_user = authenticate(request, username=user.username, password=password)
                
                if authenticated_user is not None:
                    login(request, authenticated_user)
                    
                    # Check if user is a chairperson and is approved
                    if authenticated_user.role == 'chairperson':
                        try:
                            chairperson = Chairperson.objects.get(user=authenticated_user, is_approved=True)
                            # Set chairperson session data
                            request.session['is_chairperson'] = True
                            request.session['chairperson_department'] = chairperson.department.name
                            messages.success(request, f"Welcome back, Chairperson {authenticated_user.get_full_name()}")
                            return redirect('chairperson_dashboard')
                        except Chairperson.DoesNotExist:
                            messages.error(request, "Your chairperson account is not approved or does not exist.")
                            logout(request)
                            return redirect('unified_login')
                    
                    # Check if user is a dean and is active
                    if authenticated_user.role == 'dean':
                        try:
                            dean = Dean.objects.get(user=authenticated_user, is_active=True)
                            # Set dean session data
                            request.session['is_dean'] = True
                            request.session['user_role'] = 'dean'  # Add this line
                            request.session['dean_department'] = dean.department.name
                            messages.success(request, f"Welcome back, Dean {authenticated_user.get_full_name()}")
                            return redirect('dean_dashboard')
                        except Dean.DoesNotExist:
                            messages.error(request, "Your dean account is not active or does not exist.")
                            logout(request)
                            return redirect('unified_login')
                    
                    # Check if user is a controller and is active
                    if authenticated_user.role == 'controller':
                        try:
                            controller = Controller.objects.get(user=authenticated_user, is_active=True)
                            # Set controller session data
                            request.session['is_controller'] = True
                            request.session['user_role'] = 'controller'
                            request.session['controller_department'] = controller.department.name
                            messages.success(request, f"Welcome back, Controller {authenticated_user.get_full_name()}")
                            return redirect('controller_dashboard')
                        except Controller.DoesNotExist:
                            messages.error(request, "Your controller account is not active or does not exist.")
                            logout(request)
                            return redirect('unified_login')
                    
                    # Redirect based on role if not a chairperson or dean
                    if authenticated_user.role == 'student':
                        request.session['user_role'] = 'student'  # Add this line
                        return redirect('student_dashboard')
                    elif authenticated_user.role == 'faculty':
                        request.session['user_role'] = 'faculty'  # Add this line
                        return redirect('teacher_dashboard')
                    elif authenticated_user.role == 'admin':
                        request.session['user_role'] = 'admin'  # Add this line
                        return redirect('admin_dashboard')
                    else:
                        messages.error(request, "Invalid user role.")
                        return redirect('unified_login')
                else:
                    messages.error(request, "Invalid credentials.")
                    return redirect('unified_login')
            else:
                messages.error(request, "Invalid credentials.")
                return redirect('unified_login')
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
            return redirect('unified_login')
    
    return render(request, 'attendance/fundamental_template/login.html')

@login_required
def dashboard_selection(request):
    # Get all roles for the user
    user_roles = []
    
    # Check if user is a chairperson
    is_chairperson = Chairperson.objects.filter(user=request.user, is_approved=True).exists()
    if is_chairperson:
        user_roles.append('chairperson')
    
    # Add primary role
    if request.user.role:
        user_roles.append(request.user.role)
    
    # Remove duplicates and sort
    user_roles = sorted(list(set(user_roles)))
    
    return render(request, 'attendance/fundamental_template/dashboard_selection.html', {
        'user_roles': user_roles
    })

def unified_register(request):
    if request.method == 'POST':
        role = request.POST.get('role')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        email = request.POST.get('email')
        password1 = request.POST.get('password1')
        password2 = request.POST.get('password2')

        # Validate passwords match
        if password1 != password2:
            messages.error(request, "Passwords do not match")
            return redirect('unified_register')

        # Check if email already exists
        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, "Email already exists")
            return redirect('unified_register')

        # Prevent admin registration
        if role == 'admin':
            messages.error(request, "Admin registration is not allowed through this form")
            return redirect('unified_register')

        try:
            # Create user
            user = CustomUser.objects.create_user(
                username=email,
                email=email,
                password=password1,
                first_name=first_name,
                last_name=last_name,
                role=role
            )

            # Handle role-specific registration
            if role == 'student':
                department_id = request.POST.get('department')
                program_id = request.POST.get('program')
                semester_id = request.POST.get('semester')
                
                if department_id and program_id and semester_id:
                    department = Department.objects.get(id=department_id)
                    program = Program.objects.get(id=program_id)
                    semester = Semester.objects.get(id=semester_id)
                    
                    # Generate a unique enrollment number
                    enrollment_no = f"EN{timezone.now().strftime('%Y%m%d%H%M%S')}"
                    roll_no = f"R{timezone.now().strftime('%Y%m%d%H%M%S')}"
                    
                    # Create student profile
                    student = Student.objects.create(
                        name=f"{first_name} {last_name}",
                        department=department,
                        program=program,
                        semester=semester,
                        enrollment_no=enrollment_no,
                        roll_no=roll_no,
                        session=timezone.now().year
                    )
                    
                    # Create enrollment record
                    enrollment = EnrollStudent.objects.create(
                        user=user,
                        department=department,
                        program=program,
                        semester=semester
                    )
                    
                    messages.success(request, "Registration successful! Please login.")
                    return redirect('unified_login')
                else:
                    messages.error(request, "Please fill in all required fields for student registration")
                    user.delete()  # Delete the user if student profile creation fails
                    return redirect('unified_register')

            elif role == 'faculty':
                teacher_code = request.POST.get('teacher_code')
                department_id = request.POST.get('department')
                
                if teacher_code and department_id:
                    department = Department.objects.get(id=department_id)
                    
                    # Check if teacher code already exists
                    if Teacher.objects.filter(teacher_code=teacher_code).exists():
                        messages.error(request, "Teacher code already exists")
                        user.delete()  # Delete the user if teacher profile creation fails
                        return redirect('unified_register')
                    
                    Teacher.objects.create(
                        teacher_code=teacher_code,
                        name=f"{first_name} {last_name}",
                        department=department
                    )
                    messages.success(request, "Registration successful! Please login.")
                    return redirect('unified_login')

            elif role == 'chairperson':
                department_id = request.POST.get('department')
                
                if department_id:
                    department = Department.objects.get(id=department_id)
                    
                    Chairperson.objects.create(
                        user=user,
                        department=department,
                        is_approved=False
                    )
                    messages.success(request, "Registration successful! Please wait for admin approval.")
                    return redirect('unified_login')

        except Exception as e:
            messages.error(request, f"Error during registration: {str(e)}")
            if user.id:
                user.delete()  # Delete the user if any error occurs
            return redirect('unified_register')
    
    # GET request - show registration form
    departments = Department.objects.all()
    return render(request, 'attendance/fundamental_template/register.html', {
        'departments': departments
    })

@login_required
@user_passes_test(lambda u: u.is_superuser)
def edit_semester(request, semester_id):
    semester = get_object_or_404(Semester, id=semester_id)
    if request.method == 'POST':
        name = request.POST.get('name')
        if name:
            semester.name = name
            semester.save()
            messages.success(request, 'Semester updated successfully.')
            return redirect('manage_semesters')
        else:
            messages.error(request, 'Semester name is required.')
    return render(request, 'attendance/manage_semester_template/edit_semester.html', {'semester': semester})

@login_required
@user_passes_test(lambda u: u.is_superuser)
def delete_semester(request, semester_id):
    semester = get_object_or_404(Semester, id=semester_id)
    if request.method == 'POST':
        semester.delete()
        messages.success(request, 'Semester deleted successfully.')
        return redirect('manage_semesters')
    return render(request, 'attendance/manage_semester_template/delete_semester.html', {'semester': semester})

@login_required
@chairperson_required
def chairperson_edit_course_assignment(request, assignment_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        assignment = CourseTeacher.objects.get(id=assignment_id, department=department)
    except CourseTeacher.DoesNotExist:
        messages.error(request, "Course assignment not found or you don't have permission to edit it.")
        return redirect('chairperson_assign_teacher')

    if request.method == "POST":
        course_ids = request.POST.getlist('courses')
        try:
            courses = Course.objects.filter(id__in=course_ids, department=department)
            assignment.course.set(courses)
            messages.success(request, "Course assignment updated successfully!")
            return redirect('chairperson_assign_teacher')
        except Exception as e:
            messages.error(request, f"Error updating course assignment: {str(e)}")
            return redirect('chairperson_assign_teacher')

    # GET request - show form
    available_courses = Course.objects.filter(department=department, program=assignment.program, semester=assignment.semester)
    return render(request, 'attendance/chairperson_authentication_template/edit_course_assignment.html', {
        'assignment': assignment,
        'available_courses': available_courses
    })

@login_required
@chairperson_required
def chairperson_remove_course_assignment(request, assignment_id):
    chairperson = request.chairperson
    department = chairperson.department
    
    try:
        assignment = CourseTeacher.objects.get(id=assignment_id, department=department)
        assignment.delete()
        messages.success(request, "Course assignment removed successfully!")
    except CourseTeacher.DoesNotExist:
        messages.error(request, "Course assignment not found or you don't have permission to remove it.")
    except Exception as e:
        messages.error(request, f"Error removing course assignment: {str(e)}")
    
    return redirect('chairperson_assign_teacher')

@login_required
@chairperson_required
def get_courses_by_semester(request):
    chairperson = request.chairperson
    department = chairperson.department
    
    semester_id = request.GET.get('semester_id')
    if not semester_id:
        return JsonResponse({'error': 'Semester ID is required'}, status=400)
    
    try:
        semester = Semester.objects.get(id=semester_id)
        # Filter courses by department and semester
        courses = Course.objects.filter(department=department, semester=semester)
        courses_data = [{'id': course.id, 'name': f"{course.name} ({course.code})"} for course in courses]
        return JsonResponse(courses_data, safe=False)
    except Semester.DoesNotExist:
        return JsonResponse({'error': 'Semester not found'}, status=404)

@login_required
@user_passes_test(lambda u: u.is_staff)
def admin_export_attendance_csv(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')
    
    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    selected_courses = request.GET.getlist('courses')
    
    # Convert selected_courses to integers and filter out invalid values
    try:
        selected_courses = [int(course_id) for course_id in selected_courses if course_id and course_id.isdigit()]
    except (ValueError, TypeError):
        selected_courses = []
    
    try:
        department = Department.objects.get(id=department_id)
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get courses based on filter
        if selected_courses:
            courses = Course.objects.filter(id__in=selected_courses, semester=semester)
        else:
            courses = Course.objects.filter(semester=semester)
        
        # Calculate total classes for each course
        for course in courses:
            # Get all attendance records for this course
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            
            # Count how many times each student name appears
            student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
            
            # Get the maximum count (this will be the total classes for this course)
            course.total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
        
        # Create the HttpResponse object with the appropriate CSV header
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="attendance_summary_{program.name}_{semester.name}_{from_date}_to_{to_date}.csv"'
        
        # Create CSV writer
        writer = csv.writer(response)
        
        # Write filter information
        writer.writerow(['Attendance Summary Report'])
        writer.writerow([])
        writer.writerow(['Filter Information:'])
        writer.writerow(['Department:', department.name])
        writer.writerow(['Program:', program.name])
        writer.writerow(['Semester:', semester.name])
        writer.writerow(['Date Range:', f'{from_date} to {to_date}'])
        writer.writerow(['Selected Courses:', ', '.join([course.name for course in courses])])
        writer.writerow([])
        
        # Write header rows
        header1 = ['Sr. No.', 'Student Name']
        header2 = ['', '']
        
        for course in courses:
            header1.extend([course.code, ''])
            header2.extend([f'Total Classes: {course.total_classes}', ''])
        
        header1.extend(['Total Present', 'Overall %'])
        header2.extend([f'Total Classes: {sum(course.total_classes for course in courses)}', ''])
        
        writer.writerow(header1)
        writer.writerow(header2)
        
        # Write subheader row
        subheader = ['', '']
        for course in courses:
            subheader.extend(['Present', '%'])
        subheader.extend(['', ''])
        writer.writerow(subheader)
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Write data rows
        row_number = 1
        for enroll_student in enroll_students:
            try:
                student = Student.objects.get(
                    enrollment_no=enroll_student.user.username,
                    program=program,
                    semester=semester
                )
                
                row = [str(row_number), student.name]
                total_present = 0
                total_classes_attended = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student=student,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    total_classes = course.total_classes
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    row.extend([str(present_count), f"{percentage}%"])
                    total_present += present_count
                    total_classes_attended += total_classes
                
                # Calculate overall percentage correctly
                overall_percentage = round((total_present / total_classes_attended * 100) if total_classes_attended > 0 else 0, 2)
                row.extend([str(total_present), f"{overall_percentage}%"])
                
                writer.writerow(row)
                row_number += 1
            except Student.DoesNotExist:
                continue
        
        return response
        
    except (Program.DoesNotExist, Semester.DoesNotExist) as e:
        messages.error(request, str(e))
        return redirect('attendance_summary')

@login_required
def admin_export_attendance_pdf(request):
    if not request.user.is_staff:
        messages.error(request, "Access denied. This page is for admins only.")
        return redirect('home')
    
    # Get filter parameters
    department_id = request.GET.get('department')
    program_id = request.GET.get('program')
    semester_id = request.GET.get('semester')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')
    
    if not all([department_id, program_id, semester_id, from_date, to_date]):
        messages.error(request, "All filter parameters are required")
        return redirect('attendance_report')
    
    try:
        department = Department.objects.get(id=department_id)
        program = Program.objects.get(id=program_id, department=department)
        semester = Semester.objects.get(id=semester_id, program=program)
        
        # Get all courses for the semester
        courses = Course.objects.filter(semester=semester)
        
        # Calculate total classes for each course
        course_total_classes = {}
        total_classes_all = 0
        for course in courses:
            attendance_records = Attendance.objects.filter(
                course=course,
                date__range=[from_date, to_date]
            )
            student_counts = attendance_records.values('student__name').annotate(count=Count('id'))
            total_classes = max([record['count'] for record in student_counts]) if student_counts else 0
            course_total_classes[course.id] = total_classes
            total_classes_all += total_classes
        
        # Get all enrolled students for the program and semester
        enroll_students = EnrollStudent.objects.filter(
            program=program,
            semester=semester
        ).select_related('user')
        
        # Create PDF response
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="attendance_report_{from_date}_to_{to_date}.pdf"'
        
        # Calculate page size based on number of courses
        num_courses = len(courses)
        if num_courses <= 2:
            page_size = letter
        elif num_courses <= 4:
            page_size = landscape(letter)
        else:
            # For more than 4 courses, use a custom size
            page_size = landscape((11 * inch, 17 * inch))  # Wider page for more courses
        
        # Create PDF document with appropriate page size
        doc = SimpleDocTemplate(
            response,
            pagesize=page_size,
            leftMargin=0.5*inch,
            rightMargin=0.5*inch,
            topMargin=0.5*inch,
            bottomMargin=0.5*inch
        )
        elements = []
        
        # Add title
        title = f"Attendance Report - {program.name} - {semester.name}"
        elements.append(Paragraph(title, getSampleStyleSheet()['Title']))
        
        # Add filter details
        details = [
            ['Department:', department.name],
            ['Program:', program.name],
            ['Semester:', semester.name],
            ['Date Range:', f'{from_date} to {to_date}']
        ]
        
        details_table = Table(details, colWidths=[2*inch, 4*inch])
        details_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ]))
        elements.append(details_table)
        elements.append(Spacer(1, 20))
        
        # Create table data
        data = []
        
        # Add header rows
        header1 = ['Sr. No.', 'Student Name']
        header2 = ['', '']
        
        for course in courses:
            total_classes = course_total_classes[course.id]
            header1.extend([course.code, ''])
            header2.extend([f'Total Classes: {total_classes}', ''])
        
        header1.extend(['Total Present', 'Overall %'])
        header2.extend([f'Total Classes: {total_classes_all}', ''])
        
        data.append(header1)
        data.append(header2)
        
        # Add subheader row
        subheader = ['', '']
        for course in courses:
            subheader.extend(['Present', '%'])
        subheader.extend(['', ''])
        data.append(subheader)
        
        # Add data rows
        row_number = 1
        for enroll_student in enroll_students:
            try:
                student = Student.objects.get(
                    enrollment_no=enroll_student.user.username,
                    program=program,
                    semester=semester
                )
                
                row = [str(row_number), student.name]
                total_present = 0
                total_classes_attended = 0
                
                for course in courses:
                    attendance_records = Attendance.objects.filter(
                        student=student,
                        course=course,
                        date__range=[from_date, to_date]
                    )
                    
                    total_classes = course_total_classes[course.id]
                    present_count = attendance_records.filter(status='Present').count()
                    percentage = round((present_count / total_classes * 100) if total_classes > 0 else 0, 2)
                    
                    row.extend([str(present_count), f"{percentage}%"])
                    total_present += present_count
                    total_classes_attended += total_classes
                
                # Calculate overall percentage correctly
                overall_percentage = round((total_present / total_classes_attended * 100) if total_classes_attended > 0 else 0, 2)
                row.extend([str(total_present), f"{overall_percentage}%"])
                
                data.append(row)
                row_number += 1
            except Student.DoesNotExist:
                continue
        
        # Calculate column widths based on number of courses and page size
        available_width = doc.width - (doc.leftMargin + doc.rightMargin)
        if num_courses <= 2:
            col_widths = [0.5*inch, 2*inch] + [1*inch, 1*inch] * len(courses) + [1*inch, 1*inch]
        elif num_courses <= 4:
            col_widths = [0.5*inch, 2*inch] + [0.8*inch, 0.8*inch] * len(courses) + [0.8*inch, 0.8*inch]
        else:
            # For more than 4 courses, use smaller column widths
            col_widths = [0.5*inch, 2*inch] + [0.6*inch, 0.6*inch] * len(courses) + [0.6*inch, 0.6*inch]
        
        # Create table
        table = Table(data, colWidths=col_widths)
        table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 2), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 2), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 2), 12),
            ('BACKGROUND', (0, 0), (-1, 2), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, 2), colors.black),
            ('ALIGN', (0, 3), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 3), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 3), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('WORDWRAP', (0, 0), (-1, -1), True),
        ]))
        
        elements.append(table)
        
        # Add summary statistics
        elements.append(Spacer(1, 20))
        summary = [
            ['Total Students:', str(len(data) - 3)],  # Subtract header rows
            ['Total Courses:', str(len(courses))],
            ['Date Range:', f'{from_date} to {to_date}']
        ]
        
        summary_table = Table(summary, colWidths=[2*inch, 4*inch])
        summary_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ]))
        elements.append(summary_table)
        
        # Build PDF
        doc.build(elements)
        return response
        
    except Exception as e:
        messages.error(request, f"Error generating PDF: {str(e)}")
        return redirect('attendance_report')

@login_required
def student_dashboard(request):
    if request.user.role != "student":
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')

    student = request.user
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        enrolled_courses = student_enrollment.courses.all()

        if request.method == "POST":
            if 'enroll_courses' in request.POST:
                course_ids = request.POST.getlist('courses')
                courses = Course.objects.filter(id__in=course_ids)
                
                # Validate that courses belong to student's department and program
                valid_courses = courses.filter(
                    department=student_enrollment.department,
                    program=student_enrollment.program,
                    semester=student_enrollment.semester
                )
                
                student_enrollment.courses.add(*valid_courses)
                messages.success(request, "Courses enrolled successfully!")
                return redirect('student_dashboard')

            elif 'unenroll_course' in request.POST:
                course_id = request.POST.get('course_id')
                course = get_object_or_404(Course, id=course_id)
                student_enrollment.courses.remove(course)
                messages.success(request, "Course unenrolled successfully!")
                return redirect('student_dashboard')

        # Get available courses for the student's department, program, and semester
        available_courses = Course.objects.filter(
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        ).exclude(id__in=enrolled_courses.values_list('id', flat=True))

        # --- Notification Fetching ---
        from attendance.models import Notification
        all_notifications = Notification.objects.filter(user=student)
        
        # Create a test notification if none exist (for testing purposes)
        if all_notifications.count() == 0:
            Notification.objects.create(
                user=student,
                title="Test Notification",
                message="This is a test notification to verify the notification system is working correctly.",
                notification_type='general',
                is_read=False
            )
            # Refresh the notifications query
            all_notifications = Notification.objects.filter(user=student)
        
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        recent_notifications = all_notifications.order_by('-created_at')[:5]

        return render(request, 'attendance/student_authentication_template/student_dashboard.html', {
            'student': student,
            'student_enrollment': student_enrollment,
            'enrolled_courses': enrolled_courses,
            'available_courses': available_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count
        })

    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your registration is incomplete. Please contact the administrator.")
        return redirect('student_register')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('home')

@login_required
def student_attendance_report(request):
    try:
        student = request.user
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        
        # Get all courses the student is enrolled in
        courses = student_enrollment.courses.all()
        
        # Get filter parameters
        selected_courses = request.GET.getlist('courses')
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        
        # Base queryset - filter by student's user object
        attendance_records = Attendance.objects.filter(student=student)
        
        # Apply filters
        if selected_courses and 'all' not in selected_courses:
            attendance_records = attendance_records.filter(course_id__in=selected_courses)
        if start_date:
            attendance_records = attendance_records.filter(date__gte=start_date)
        if end_date:
            attendance_records = attendance_records.filter(date__lte=end_date)
        
        # Order by date and course
        attendance_records = attendance_records.order_by('date', 'course')
        
        context = {
            'courses': courses,
            'attendance_records': attendance_records,
            'selected_courses': selected_courses,
            'start_date': start_date,
            'end_date': end_date,
            'student': student,
            'student_enrollment': student_enrollment
        }
        
        return render(request, 'attendance/student_authentication_template/student_attendance_report.html', context)
    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your enrollment record was not found. Please contact the administrator.")
        return redirect('student_dashboard')
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('student_dashboard')

@login_required
def export_student_attendance_csv(request):
    try:
        student = request.user
        student_enrollment = EnrollStudent.objects.get(user=student)
        student_instance = Student.objects.get(
            name=f"{student.first_name} {student.last_name}",
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        )
        
        # Get filter parameters
        selected_courses = request.GET.getlist('courses')
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        
        # Base queryset
        attendance_records = Attendance.objects.filter(student=student_instance)
        
        # Apply filters
        if selected_courses and 'all' not in selected_courses:
            # Convert string IDs to integers
            course_ids = [int(course_id) for course_id in selected_courses]
            attendance_records = attendance_records.filter(course_id__in=course_ids)
        if start_date:
            attendance_records = attendance_records.filter(date__gte=start_date)
        if end_date:
            attendance_records = attendance_records.filter(date__lte=end_date)
        
        # Create the HttpResponse object with CSV header
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="attendance_report_{student.username}.csv"'
        
        # Create CSV writer
        writer = csv.writer(response)
        
        # Write Overall Attendance Summary
        writer.writerow(['Overall Attendance Summary'])
        writer.writerow(['Total Classes', 'Present', 'Absent', 'Attendance %'])
        total_classes = attendance_records.count()
        present_count = attendance_records.filter(status='Present').count()
        absent_count = total_classes - present_count
        attendance_percentage = (present_count / total_classes * 100) if total_classes > 0 else 0
        writer.writerow([total_classes, present_count, absent_count, f"{round(attendance_percentage, 2)}%"])
        writer.writerow([])  # Empty row for spacing
        
        # Write Per-Course Attendance Summary
        writer.writerow(['Per-Course Attendance Summary'])
        writer.writerow(['Course Code', 'Total Classes', 'Present', 'Absent', 'Attendance %'])
        for course in student_enrollment.courses.all():
            if selected_courses and 'all' not in selected_courses and str(course.id) not in selected_courses:
                continue
                
            course_records = attendance_records.filter(course=course)
            course_total = course_records.count()
            course_present = course_records.filter(status='Present').count()
            course_absent = course_total - course_present
            course_percentage = (course_present / course_total * 100) if course_total > 0 else 0
            writer.writerow([
                course.code,
                course_total,
                course_present,
                course_absent,
                f"{round(course_percentage, 2)}%"
            ])
        writer.writerow([])  # Empty row for spacing
        
        # Write detailed attendance records
        writer.writerow(['Detailed Attendance Records'])
        writer.writerow(['Date', 'Course Code', 'Status', 'Time'])
        for record in attendance_records.order_by('-date', '-marked_at'):
            writer.writerow([
                record.date,
                record.course.code,
                record.status,
                record.marked_at.strftime('%H:%M:%S') if record.marked_at else '-'
            ])
        
        return response
        
    except Exception as e:
        messages.error(request, f"Error exporting attendance: {str(e)}")
        return redirect('student_view_attendance')

@login_required
def export_student_attendance_pdf(request):
    try:
        student = request.user
        student_enrollment = EnrollStudent.objects.get(user=student)
        student_instance = Student.objects.get(
            name=f"{student.first_name} {student.last_name}",
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        )
        
        # Get filter parameters
        selected_courses = request.GET.getlist('courses')
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        
        # Base queryset
        attendance_records = Attendance.objects.filter(student=student_instance)
        
        # Apply filters
        if selected_courses and 'all' not in selected_courses:
            # Convert string IDs to integers
            course_ids = [int(course_id) for course_id in selected_courses]
            attendance_records = attendance_records.filter(course_id__in=course_ids)
        if start_date:
            attendance_records = attendance_records.filter(date__gte=start_date)
        if end_date:
            attendance_records = attendance_records.filter(date__lte=end_date)
        
        # Calculate overall statistics
        total_classes = attendance_records.count()
        present_count = attendance_records.filter(status='Present').count()
        absent_count = total_classes - present_count
        attendance_percentage = (present_count / total_classes * 100) if total_classes > 0 else 0
        
        # Create PDF
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="attendance_report_{student.username}.pdf"'
        
        # Create PDF document
        doc = SimpleDocTemplate(response, pagesize=letter)
        elements = []
        
        # Add title
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=16,
            spaceAfter=30
        )
        elements.append(Paragraph(f"Attendance Report for {student.get_full_name()}", title_style))
        
        # Add Overall Attendance Summary
        elements.append(Paragraph("Overall Attendance Summary", styles['Heading2']))
        summary_data = [
            ['Total Classes', str(total_classes)],
            ['Present', str(present_count)],
            ['Absent', str(absent_count)],
            ['Attendance %', f"{round(attendance_percentage, 2)}%"]
        ]
        summary_table = Table(summary_data, colWidths=[200, 100])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 12),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(summary_table)
        elements.append(Spacer(1, 20))
        
        # Add Per-Course Attendance Summary
        elements.append(Paragraph("Per-Course Attendance Summary", styles['Heading2']))
        course_data = [['Course Code', 'Total Classes', 'Present', 'Absent', 'Attendance %']]
        for course in student_enrollment.courses.all():
            if selected_courses and 'all' not in selected_courses and str(course.id) not in selected_courses:
                continue
                
            course_records = attendance_records.filter(course=course)
            course_total = course_records.count()
            course_present = course_records.filter(status='Present').count()
            course_absent = course_total - course_present
            course_percentage = (course_present / course_total * 100) if course_total > 0 else 0
            course_data.append([
                course.code,
                str(course_total),
                str(course_present),
                str(course_absent),
                f"{round(course_percentage, 2)}%"
            ])
        
        course_table = Table(course_data, colWidths=[100, 100, 100, 100, 100])
        course_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(course_table)
        elements.append(Spacer(1, 20))
        
        # Add detailed attendance records
        elements.append(Paragraph("Detailed Attendance Records", styles['Heading2']))
        if attendance_records.exists():
            data = [['Date', 'Course Code', 'Status', 'Time']]
            for record in attendance_records.order_by('-date', '-marked_at'):
                data.append([
                    record.date.strftime('%Y-%m-%d'),
                    record.course.code,
                    record.status,
                    record.marked_at.strftime('%H:%M:%S') if record.marked_at else '-'
                ])
            
            table = Table(data, colWidths=[100, 100, 100, 100])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(table)
        else:
            elements.append(Paragraph("No attendance records found.", styles['Normal']))
        
        # Build PDF
        doc.build(elements)
        return response
        
    except Exception as e:
        messages.error(request, f"Error exporting attendance: {str(e)}")
        return redirect('student_view_attendance')

@login_required
def get_teachers_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        print(f"Fetching teachers for department ID: {department_id}") # Debug log
        
        if not department_id:
            return JsonResponse({'error': 'Department ID is required'}, status=400)
            
        # Get all teachers from the department who have associated CustomUser accounts
        # Removed the dean filter to show all teachers
        teachers = CustomUser.objects.filter(
            role='faculty',
            teacher__department_id=department_id
        ).select_related('teacher').values(
            'id',
            'first_name',
            'last_name',
            'email',
            'teacher__teacher_code'
        ).order_by('first_name', 'last_name')
        
        print(f"Found {teachers.count()} teachers in department") # Debug log
        
        # Format teacher data
        teachers_data = [{
            'id': teacher['id'],
            'name': f"{teacher['first_name']} {teacher['last_name']}",
            'teacher_code': teacher['teacher__teacher_code'],
            'email': teacher['email']
        } for teacher in teachers]
        
        print(f"Returning data: {teachers_data}") # Debug log
        return JsonResponse({'teachers': teachers_data})
    except Exception as e:
        print(f"Error in get_teachers_by_department: {str(e)}") # Debug log
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def student_view_attendance(request):
    try:
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=request.user)
        
        # Get the Student instance
        student = Student.objects.get(
            name=f"{request.user.first_name} {request.user.last_name}",
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        )
        
        # Get all courses the student is enrolled in
        enrolled_courses = student_enrollment.courses.all()
        
        if not enrolled_courses.exists():
            messages.warning(request, "You are not enrolled in any courses. Please enroll in courses from your dashboard.")
            return redirect('student_dashboard')
        
        if request.method == 'POST':
            selected_courses = request.POST.getlist('courses')
            start_date = request.POST.get('start_date')
            end_date = request.POST.get('end_date')
            
            # Base queryset
            attendance_records = Attendance.objects.filter(student=student)
            
            # Apply filters
            if selected_courses and 'all' not in selected_courses:
                attendance_records = attendance_records.filter(course_id__in=selected_courses)
            if start_date:
                attendance_records = attendance_records.filter(date__gte=start_date)
            if end_date:
                attendance_records = attendance_records.filter(date__lte=end_date)
            
            # Calculate overall statistics
            total_classes = attendance_records.count()
            present_count = attendance_records.filter(status='Present').count()
            absent_count = total_classes - present_count
            attendance_percentage = (present_count / total_classes * 100) if total_classes > 0 else 0
            
            # Calculate per-course statistics
            course_stats = {}
            for course in enrolled_courses:
                if selected_courses and 'all' not in selected_courses and str(course.id) not in selected_courses:
                    continue
                    
                course_records = attendance_records.filter(course=course)
                course_total = course_records.count()
                course_present = course_records.filter(status='Present').count()
                course_absent = course_total - course_present
                course_percentage = (course_present / course_total * 100) if course_total > 0 else 0
                
                course_stats[course.id] = {
                    'name': course.name,
                    'code': course.code,
                    'total_classes': course_total,
                    'present_count': course_present,
                    'absent_count': course_absent,
                    'percentage': round(course_percentage, 2)
                }
            
            context = {
                'courses': enrolled_courses,
                'attendance_records': attendance_records.order_by('-date', '-marked_at'),
                'total_classes': total_classes,
                'present_count': present_count,
                'absent_count': absent_count,
                'attendance_percentage': round(attendance_percentage, 2),
                'selected_courses': selected_courses,
                'start_date': start_date,
                'end_date': end_date,
                'course_stats': course_stats,
                'current_date': datetime.now().strftime('%Y-%m-%d')
            }
        else:
            context = {
                'courses': enrolled_courses,
                'attendance_records': None,
                'current_date': datetime.now().strftime('%Y-%m-%d')
            }
        
        return render(request, 'attendance/student_authentication_template/view_attendance.html', context)
        
    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your enrollment record was not found. Please contact the administrator.")
        return redirect('student_dashboard')
    except Student.DoesNotExist:
        messages.error(request, "Your student record was not found. Please contact the administrator.")
        return redirect('student_dashboard')
    except Exception as e:
        messages.error(request, f"Error viewing attendance: {str(e)}")
        return redirect('student_dashboard')

def registration_selection(request):
    """View for selecting registration type (Student or Faculty)"""
    return render(request, 'attendance/registration_selection.html')

def get_programs_by_department(request):
    try:
        department_id = request.GET.get('department_id')
        if department_id:
            programs = Program.objects.filter(department_id=department_id).values('id', 'name')
            return JsonResponse({'programs': list(programs)})
        return JsonResponse({'programs': []})
    except Exception as e:
        print(f"Error in get_programs_by_department: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)

def get_semesters_by_program(request):
    try:
        program_id = request.GET.get('program_id')
        if program_id:
            semesters = Semester.objects.filter(program_id=program_id).values('id', 'name')
            return JsonResponse({'semesters': list(semesters)})
        return JsonResponse({'semesters': []})
    except Exception as e:
        print(f"Error in get_semesters_by_program: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)

from .forms import AttendanceChangeRequestForm

@login_required
def request_attendance_change(request):
    if request.user.role != 'faculty':
        messages.error(request, 'Only faculty can request attendance changes.')
        return redirect('teacher_dashboard')
    if request.method == 'POST':
        form = AttendanceChangeRequestForm(request.POST)
        if form.is_valid():
            change_request = form.save(commit=False)
            change_request.faculty = request.user
            change_request.status = 'pending'
            change_request.save()

            # Create notifications for admin and chairperson
            admin_users = CustomUser.objects.filter(Q(is_superuser=True) | Q(role='admin'))
            for admin in admin_users:
                Notification.objects.create(
                    user=admin,
                    message=f"New attendance change request from {request.user.get_full_name()} for {change_request.student.name}"
                )

            # Notify chairperson of the department
            chairperson = Chairperson.objects.filter(
                department=change_request.course.department,
                is_approved=True
            ).first()
            if chairperson:
                Notification.objects.create(
                    user=chairperson.user,
                    message=f"New attendance change request from {request.user.get_full_name()} for {change_request.student.name}"
                )

            messages.success(request, 'Attendance change request submitted successfully.')
            return redirect('teacher_dashboard')
    else:
        form = AttendanceChangeRequestForm(request.user)

    return render(request, 'attendance/request_attendance_change.html', {'form': form})

@login_required
def attendance_change_requests_admin(request):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
    requests = AttendanceChangeRequest.objects.select_related('faculty', 'student', 'course').order_by('-created_at')
    return render(request, 'attendance/admin_authentication_template/attendance_change_requests.html', {'requests': requests})

@login_required
def approve_attendance_change_request(request, request_id):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
    try:
        change_request = AttendanceChangeRequest.objects.get(id=request_id)
        
        # Update attendance record - use filter().first() instead of get()
        attendance = Attendance.objects.filter(
            student=change_request.student,
            course=change_request.course,
            date=change_request.date
        ).first()
        
        if not attendance:
            messages.error(request, "Attendance record not found.")
            return redirect('attendance_change_requests_admin')
        
        # Store old status for audit
        old_status = attendance.status
        
        # Update status
        attendance.status = change_request.requested_status
        attendance.save()
        
        # Update request status
        change_request.status = 'approved'
        change_request.decision = f"Approved by {request.user.get_full_name()} on {timezone.now().strftime('%Y-%m-%d %H:%M:%S')}. Changed from {old_status} to {change_request.requested_status}."
        change_request.save()
        
        # Notify faculty only if faculty exists
        if change_request.faculty:
            Notification.objects.create(
                user=change_request.faculty,
                message=f"Your attendance change request for {change_request.student.name} in {change_request.course.name} on {change_request.date} has been approved."
            )
        
        messages.success(request, "Request approved and attendance updated successfully.")
    except Exception as e:
        messages.error(request, f"Error: {str(e)}")
    return redirect('attendance_change_requests_admin')

@login_required
def reject_attendance_change_request(request, request_id):
    if not request.user.is_superuser and request.user.role != 'admin':
        messages.error(request, "Access denied. Admin privileges required.")
        return redirect('home')
    try:
        change_request = AttendanceChangeRequest.objects.get(id=request_id)
        change_request.status = 'rejected'
        change_request.decision = f"Rejected by {request.user.get_full_name()}"
        change_request.save()
        # Notify faculty
        Notification.objects.create(
            user=change_request.faculty,
            message=f"Your attendance change request for {change_request.student} in {change_request.course} on {change_request.date} has been rejected."
        )
        messages.success(request, "Request rejected.")
    except Exception as e:
        messages.error(request, f"Error: {str(e)}")
    return redirect('attendance_change_requests_admin')

@login_required
@chairperson_required
def attendance_change_requests_chairperson(request):
    chairperson = Chairperson.objects.get(user=request.user)
    department = chairperson.department
    # Only requests for students/courses in this department
    requests = AttendanceChangeRequest.objects.filter(
        course__program__department=department
    ).select_related('faculty', 'student', 'course').order_by('-created_at')
    return render(request, 'attendance/chairperson_authentication_template/attendance_change_requests.html', {'requests': requests})

@login_required
@chairperson_required
def approve_attendance_change_request_chairperson(request, request_id):
    chairperson = Chairperson.objects.get(user=request.user)
    department = chairperson.department
    try:
        change_request = AttendanceChangeRequest.objects.get(id=request_id, course__program__department=department)
        attendance = Attendance.objects.filter(
            student=change_request.student,
            course=change_request.course,
            date=change_request.date
        ).first()
        if attendance:
            attendance.status = change_request.requested_status
            attendance.save()
        change_request.status = 'approved'
        change_request.decision = f"Approved by Chairperson {request.user.get_full_name()}"
        change_request.save()
        Notification.objects.create(
            user=change_request.faculty,
            message=f"Your attendance change request for {change_request.student} in {change_request.course} on {change_request.date} has been approved by Chairperson."
        )
        messages.success(request, "Request approved and attendance updated.")
    except Exception as e:
        messages.error(request, f"Error: {str(e)}")
    return redirect('attendance_change_requests_chairperson')

@login_required
@chairperson_required
def reject_attendance_change_request_chairperson(request, request_id):
    chairperson = Chairperson.objects.get(user=request.user)
    department = chairperson.department
    try:
        change_request = AttendanceChangeRequest.objects.get(id=request_id, course__program__department=department)
        change_request.status = 'rejected'
        change_request.decision = f"Rejected by Chairperson {request.user.get_full_name()}"
        change_request.save()
        Notification.objects.create(
            user=change_request.faculty,
            message=f"Your attendance change request for {change_request.student} in {change_request.course} on {change_request.date} has been rejected by Chairperson."
        )
        messages.success(request, "Request rejected.")
    except Exception as e:
        messages.error(request, f"Error: {str(e)}")
    return redirect('attendance_change_requests_chairperson')

@login_required
def get_course_dates(request, course_id):
    """Get dates where attendance was marked for a course"""
    try:
        dates = Attendance.objects.filter(
            course_id=course_id
        ).values_list('date', flat=True).distinct().order_by('date')
        return JsonResponse({'dates': list(dates)})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_course_students(request, course_id, date):
    """Get students with attendance records for a course on a specific date"""
    try:
        students = Student.objects.filter(
            attendance__course_id=course_id,
            attendance__date=date
        ).distinct().values('id', 'name')
        return JsonResponse({'students': list(students)})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def get_attendance_status(request, course_id, date, student_id):
    """Get current attendance status for a student on a specific date"""
    try:
        attendance = Attendance.objects.get(
            course_id=course_id,
            date=date,
            student_id=student_id
        )
        return JsonResponse({'status': attendance.status})
    except Attendance.DoesNotExist:
        return JsonResponse({'error': 'Attendance record not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def request_attendance_change(request):
    if request.user.role != 'faculty':
        messages.error(request, 'Only faculty can request attendance changes.')
        return redirect('teacher_dashboard')

    if request.method == 'POST':
        form = AttendanceChangeRequestForm(request.user, request.POST)
        if form.is_valid():
            change_request = form.save(commit=False)
            change_request.faculty = request.user
            change_request.status = 'pending'
            change_request.save()

            # Create notifications for admin and chairperson
            admin_users = CustomUser.objects.filter(Q(is_superuser=True) | Q(role='admin'))
            for admin in admin_users:
                Notification.objects.create(
                    user=admin,
                    message=f"New attendance change request from {request.user.get_full_name()} for {change_request.student.name}"
                )

            # Notify chairperson of the department
            chairperson = Chairperson.objects.filter(
                department=change_request.course.department,
                is_approved=True
            ).first()
            if chairperson:
                Notification.objects.create(
                    user=chairperson.user,
                    message=f"New attendance change request from {request.user.get_full_name()} for {change_request.student.name}"
                )

            messages.success(request, 'Attendance change request submitted successfully.')
            return redirect('teacher_dashboard')
    else:
        form = AttendanceChangeRequestForm(request.user)

    return render(request, 'attendance/request_attendance_change.html', {'form': form})

@login_required
def mark_notification_read(request):
    if request.method == 'POST':
        notification_id = request.POST.get('notification_id')
        try:
            notification = Notification.objects.get(id=notification_id, user=request.user)
            notification.is_read = True
            notification.save()
            return JsonResponse({'status': 'success'})
        except Notification.DoesNotExist:
            return JsonResponse({'error': 'Notification not found'}, status=404)
    return JsonResponse({'error': 'Invalid request'}, status=400)

@login_required
def mark_all_notifications_read(request):
    if request.method == 'POST':
        Notification.objects.filter(user=request.user, is_read=False).update(is_read=True)
        return JsonResponse({'status': 'success'})
    return JsonResponse({'error': 'Invalid request'}, status=400)

@login_required
def view_all_notifications(request):
    notifications = Notification.objects.filter(user=request.user).order_by('-created_at')
    unread_count = notifications.filter(is_read=False).count()
    
    # Mark all as read when viewing all notifications
    if request.GET.get('mark_read'):
        notifications.filter(is_read=False).update(is_read=True)
    
    return render(request, 'attendance/notifications.html', {
        'notifications': notifications,
        'unread_count': unread_count
    })

# Update the teacher_dashboard view to include notification counts
@login_required
def teacher_dashboard(request):
    if request.user.role not in ['faculty', 'chairperson']:
        messages.error(request, "You are not authorized to access this page.")
        return redirect('home')
    
    try:
        # Get teacher's course assignments
        course_assignments = CourseTeacher.objects.filter(
            user=request.user
        ).select_related(
            'department', 'program', 'semester'
        ).prefetch_related('course').order_by('program', 'semester')
        
        # Calculate total number of courses
        total_courses = sum(assignment.course.count() for assignment in course_assignments)
        
        # Get all notifications for the user
        all_notifications = Notification.objects.filter(user=request.user)
        
        # Get unread count
        unread_notifications_count = all_notifications.filter(is_read=False).count()
        
        # Get recent notifications separately
        recent_notifications = Notification.objects.filter(
            user=request.user
        ).order_by('-created_at')[:10]
        
        # Get attendance change requests for courses taught by this teacher
        assigned_courses = []
        for assignment in course_assignments:
            assigned_courses.extend(assignment.course.all())
        
        attendance_change_requests = AttendanceChangeRequest.objects.filter(
            course__in=assigned_courses,
            status='pending'
        ).select_related('student', 'course').order_by('-created_at')
        
        context = {
            'course_assignments': course_assignments,
            'total_courses': total_courses,
            'notifications': recent_notifications,
            'unread_notifications_count': unread_notifications_count,
            'user': request.user,
            'attendance_change_requests': attendance_change_requests
        }
        
        return render(request, 'attendance/teacher_authentication_template/teacher_dashboard.html', context)
        
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
        return redirect('unified_login')

@login_required
def assign_chairperson(request):
    if not request.user.is_staff:
        messages.error(request, "You are not authorized to perform this action.")
        return redirect('home')
    
    if request.method == 'POST':
        teacher_id = request.POST.get('teacher_id')
        department_id = request.POST.get('department_id')
        
        try:
            # Get the teacher and department
            teacher = Teacher.objects.get(id=teacher_id)
            department = Department.objects.get(id=department_id)
            
            # Check if teacher belongs to the selected department
            if teacher.department != department:
                messages.error(request, "Selected teacher does not belong to the chosen department.")
                return redirect('assign_chairperson')
            
            # Create chairperson username and password
            original_username = teacher.user.username
            chairperson_username = f"{original_username}_chairperson"
            password = teacher.user.password  # This will be the hashed password
            
            # Create new user for chairperson role
            chairperson_user = CustomUser.objects.create_user(
                username=chairperson_username,
                email=chairperson_username,  # Using username as email
                password=teacher.user.password,  # Using the same hashed password
                first_name=teacher.user.first_name,
                last_name=teacher.user.last_name,
                role='chairperson'
            )
            
            # Create chairperson profile
            chairperson = Chairperson.objects.create(
                user=chairperson_user,
                department=department,
                is_approved=True
            )
            
            # Create notification for the teacher
            notification = Notification.objects.create(
                user=teacher.user,
                message=f"You have been appointed as the Chairperson of {department.name} department. You can login as chairperson using username: {chairperson_username} with your existing password.",
                notification_type='chairperson_assignment'
            )
            
            messages.success(request, f"Successfully appointed {teacher.name} as Chairperson of {department.name}")
            return redirect('admin_dashboard')
            
        except Teacher.DoesNotExist:
            messages.error(request, "Selected teacher not found.")
        except Department.DoesNotExist:
            messages.error(request, "Selected department not found.")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    # GET request - show form
    departments = Department.objects.all()
    teachers = Teacher.objects.all()
    return render(request, 'attendance/admin_authentication_template/assign_chairperson.html', {
        'departments': departments,
        'teachers': teachers
    })

@login_required
@chairperson_required
def chairperson_change_password(request):
    if request.method == 'POST':
        current_password = request.POST.get('current_password')
        new_password1 = request.POST.get('new_password1')
        new_password2 = request.POST.get('new_password2')
        
        # Validate current password
        if not request.user.check_password(current_password):
            messages.error(request, 'Current password is incorrect.')
            return redirect('chairperson_dashboard')
        
        # Validate new passwords match
        if new_password1 != new_password2:
            messages.error(request, 'New passwords do not match.')
            return redirect('chairperson_dashboard')
        
        # Validate new password is not the default password
        if new_password1 == 'password123':
            messages.error(request, 'Please choose a different password than the default one.')
            return redirect('chairperson_dashboard')
        
        # Validate password strength
        if len(new_password1) < 8:
            messages.error(request, 'Password must be at least 8 characters long.')
            return redirect('chairperson_dashboard')
        
        try:
            # Set new password
            request.user.set_password(new_password1)
            request.user.save()
            
            # Update session to prevent logout
            update_session_auth_hash(request, request.user)
            
            messages.success(request, 'Your password was successfully updated!')
            
            # Remove first login flag if it exists
            if 'first_login' in request.session:
                del request.session['first_login']
                
        except Exception as e:
            messages.error(request, f'An error occurred while changing password: {str(e)}')
            
    return redirect('chairperson_dashboard')

def is_dean(user):
    return user.is_authenticated and user.role == 'dean'

@login_required
@user_passes_test(is_dean)
def dean_dashboard(request):
    departments = Department.objects.all()
    return render(request, 'attendance/dean_authentication_template/dean_dashboard.html', {
        'departments': departments
    })

@login_required
@user_passes_test(is_dean)
def dean_manage_chairpersons(request):
    departments = Department.objects.all()
    chairpersons = Chairperson.objects.all().order_by('department__name')
    
    if request.method == 'POST':
        teacher_id = request.POST.get('teacher_id')
        department_id = request.POST.get('department_id')
        
        try:
            # Get the teacher user and department
            teacher_user = CustomUser.objects.get(id=teacher_id, role='faculty')
            department = Department.objects.get(id=department_id)
            
            # Get the teacher profile
            teacher = Teacher.objects.get(user=teacher_user)
            
            # Check if teacher belongs to the selected department
            if teacher.department != department:
                messages.error(request, "Selected teacher does not belong to the chosen department.")
                return redirect('dean_manage_chairpersons')
            
            # Check if department already has a chairperson
            if Chairperson.objects.filter(department=department, is_approved=True).exists():
                messages.error(request, f"Department {department.name} already has a chairperson.")
                return redirect('dean_manage_chairpersons')
            
            # Create chairperson username using email
            original_email = teacher_user.email
            chairperson_email = original_email.replace('@', '_chairperson@')
            chairperson_username = f"{teacher_user.username}_chairperson"
            
            # Create temporary password
            temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            
            # Create new user for chairperson role
            chairperson_user = CustomUser.objects.create_user(
                username=chairperson_username,
                email=chairperson_email,
                password=temp_password,
                first_name=teacher_user.first_name,
                last_name=teacher_user.last_name,
                role='chairperson'
            )
            
            # Create chairperson profile
            chairperson = Chairperson.objects.create(
                user=chairperson_user,
                department=department,
                teacher_code=teacher.teacher_code,
                is_approved=True
            )
            
            # Create detailed notification message
            notification_message = f"""
Congratulations! You have been appointed as the Chairperson of {department.name} department.

Your Chairperson Login Credentials:
Username: {chairperson_username}
Password: {temp_password}

Please log in to the unified login page with these credentials.
For security reasons, you will be required to change your password upon first login.

Note: This is a separate account for your chairperson role. You can continue to use your faculty account ({teacher_user.username}) for faculty-related activities.
            """
            
            # Create notification for the teacher's faculty account
            Notification.objects.create(
                user=teacher_user,
                title=f"Chairperson Appointment - {department.name}",
                message=notification_message,
                notification_type='appointment'
            )
            
            # Send email notification to faculty email
            try:
                send_mail(
                    f"Chairperson Appointment - {department.name}",
                    notification_message,
                    settings.DEFAULT_FROM_EMAIL,
                    [original_email],
                    fail_silently=False,
                )
            except Exception as e:
                print(f"Error sending email: {str(e)}")
                # Continue even if email fails
            
            messages.success(request, f"Successfully appointed {teacher_user.get_full_name()} as Chairperson of {department.name}")
            return redirect('dean_manage_chairpersons')
            
        except CustomUser.DoesNotExist:
            messages.error(request, "Selected teacher not found.")
        except Teacher.DoesNotExist:
            messages.error(request, "Teacher profile not found.")
        except Department.DoesNotExist:
            messages.error(request, "Selected department not found.")
        except Exception as e:
            messages.error(request, f"An error occurred: {str(e)}")
    
    return render(request, 'attendance/dean_authentication_template/manage_chairpersons.html', {
        'departments': departments,
        'chairpersons': chairpersons
    })

@login_required
@user_passes_test(is_dean)
def dean_remove_chairperson(request, chairperson_id):
    try:
        chairperson = Chairperson.objects.select_related('user', 'department').get(id=chairperson_id)
        department_name = chairperson.department.name
        chairperson_user = chairperson.user
        # Get the original teacher user
        teacher_user = CustomUser.objects.get(
            username=chairperson_user.username.replace('_chairperson', ''),
            role='faculty'
        )
        # Create removal notification message
        notification_message = f"""
Your chairperson role for {department_name} has been removed.
Your chairperson account ({chairperson_user.username}) has been deactivated.

You can continue to use your faculty account ({teacher_user.username}) for faculty-related activities.
        """
        # Send notification to the teacher's faculty account
        Notification.objects.create(
            user=teacher_user,
            title=f"Chairperson Role Removed - {department_name}",
            message=notification_message,
            notification_type='removal'
        )
        # Send email notification to faculty email
        try:
            send_mail(
                f"Chairperson Role Removed - {department_name}",
                notification_message,
                settings.DEFAULT_FROM_EMAIL,
                [teacher_user.email],
                fail_silently=False,
            )
        except Exception as e:
            print(f"Error sending email: {str(e)}")
            # Continue even if email fails
        # Delete the chairperson user account
        chairperson_user.delete()  # This will cascade delete the Chairperson record due to OneToOneField
        messages.success(request, f"Chairperson role has been removed from {teacher_user.get_full_name()}")
    except Chairperson.DoesNotExist:
        messages.error(request, "Chairperson record not found.")
    except Exception as e:
        messages.error(request, f"Error removing chairperson: {str(e)}")
    return redirect('dean_manage_chairpersons')


@login_required
@user_passes_test(lambda u: u.role == 'admin')
def appoint_dean(request):
    departments = Department.objects.all()
    deans = Dean.objects.select_related('teacher', 'teacher__department', 'teacher__user').filter(is_active=True)
    
    if request.method == 'POST':
        department_id = request.POST.get('department_id')
        teacher_id = request.POST.get('teacher_id')
        
        if not department_id or not teacher_id:
            messages.error(request, "Both initial department and teacher must be selected.")
            return redirect('appoint_dean')
            
        try:
            # Get the teacher and department
            user = CustomUser.objects.get(id=teacher_id)
            teacher = Teacher.objects.get(user=user)
            department = Department.objects.get(id=department_id)
            
            # Check if teacher belongs to the selected department
            if teacher.department != department:
                messages.error(request, "Selected teacher does not belong to the chosen department.")
                return redirect('appoint_dean')
            
            # Check if university already has a dean
            if Dean.objects.filter(is_active=True).exists():
                messages.error(request, f"The university already has an active Dean. Please remove the current Dean before appointing a new one.")
                return redirect('appoint_dean')
            
            # Create dean username using email
            original_email = teacher.user.email
            dean_email = original_email.replace('@', '_dean@')
            dean_username = f"{teacher.user.username}_dean"
            
            # Create temporary password
            temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            
            # Create new user for dean role
            dean_user = CustomUser.objects.create_user(
                username=dean_username,
                email=dean_email,
                password=temp_password,
                first_name=teacher.user.first_name,
                last_name=teacher.user.last_name,
                role='dean'
            )
            
            # Create dean record
            dean = Dean.objects.create(
                user=dean_user,
                teacher=teacher,
                department=department,
                is_active=True
            )
            
            # Create detailed notification message
            notification_message = f"""
Congratulations! You have been appointed as the Dean of the University.

As Dean, you will oversee all departments and their respective chairpersons. Your role is crucial in maintaining academic standards and coordinating between different departments.

Your Dean Login Credentials:
Username: {dean_username}
Password: {temp_password}

Please log in to the unified login page with these credentials.
For security reasons, you will be required to change your password upon first login.

Note: 
1. This is a separate account for your Dean role
2. You can continue to use your faculty account ({teacher.user.username}) for faculty-related activities
3. As Dean, you will have oversight of all departments and their chairpersons
            """
            
            # Create notification for the teacher's faculty account
            Notification.objects.create(
                user=teacher.user,  # Send to faculty account
                title="University Dean Appointment",
                message=notification_message,
                notification_type='appointment'
            )
            
            # Send email notification to faculty email
            try:
                send_mail(
                    "Appointment as University Dean",
                    notification_message,
                    settings.DEFAULT_FROM_EMAIL,
                    [original_email],  # Send to faculty email
                    fail_silently=False,
                )
            except Exception as e:
                print(f"Error sending email: {str(e)}")
                # Continue even if email fails
            
            messages.success(request, f"{teacher.name} has been appointed as the Dean of the University successfully!")
            
        except CustomUser.DoesNotExist:
            messages.error(request, "Selected teacher not found.")
        except Teacher.DoesNotExist:
            messages.error(request, "Teacher profile not found.")
        except Department.DoesNotExist:
            messages.error(request, "Selected department not found.")
        except Exception as e:
            messages.error(request, f"Error appointing dean: {str(e)}")
        
        return redirect('appoint_dean')
    
    context = {
        'departments': departments,
        'deans': deans,
    }
    return render(request, 'attendance/admin_authentication_template/appoint_dean.html', context)

@login_required
@user_passes_test(lambda u: u.role == 'admin')
def remove_dean(request, dean_id):
    try:
        dean = Dean.objects.select_related('user', 'teacher', 'department').get(id=dean_id)
        teacher = dean.teacher
        dean_user = dean.user
        
        # Create removal notification message
        notification_message = f"""
Your role as the Dean of the University has been concluded.

Important Information:
1. Your dean account ({dean_user.username}) has been deactivated
2. You can continue to use your faculty account ({teacher.user.username}) for faculty-related activities
3. All dean-related access and permissions have been revoked

Thank you for your service as the University Dean.
        """
        
        # Send notification to the teacher's faculty account
        Notification.objects.create(
            user=teacher.user,  # Send to faculty account
            title="University Dean Role Removal",
            message=notification_message,
            notification_type='removal'
        )
        
        # Send email notification to faculty email
        try:
            send_mail(
                "Removal from University Dean Position",
                notification_message,
                settings.DEFAULT_FROM_EMAIL,
                [teacher.user.email],  # Send to faculty email
                fail_silently=False,
            )
        except Exception as e:
            print(f"Error sending email: {str(e)}")
            # Continue even if email fails
        
        # Delete the dean user account
        dean_user.delete()  # This will cascade delete the Dean record due to OneToOneField
        
        messages.success(request, f"{teacher.name} has been removed from the position of University Dean")
    except Dean.DoesNotExist:
        messages.error(request, "Dean record not found.")
    except Exception as e:
        messages.error(request, f"Error removing dean: {str(e)}")
    
    return redirect('appoint_dean')

@login_required
@user_passes_test(is_dean)
def review_chairperson_request(request, request_id):
    chairperson_request = get_object_or_404(ChairpersonRequest, id=request_id)
    dean = get_object_or_404(Dean, user=request.user)
    
    if request.method == 'POST':
        action = request.POST.get('action')
        notes = request.POST.get('notes', '')
        
        if action in ['approve', 'reject']:
            chairperson_request.status = 'approved' if action == 'approve' else 'rejected'
            chairperson_request.reviewed_by = dean
            chairperson_request.reviewed_at = timezone.now()
            chairperson_request.review_notes = notes
            chairperson_request.save()
            
            # Create notification for chairperson
            Notification.objects.create(
                user=chairperson_request.chairperson.user,
                message=f"Your request to {chairperson_request.request_type} {chairperson_request.model_name} has been {chairperson_request.status}"
            )
            
            messages.success(request, f'Request {chairperson_request.status} successfully!')
        
        return redirect('dean_dashboard')
    
    context = {
        'request': chairperson_request,
    }
    return render(request, 'attendance/dean_authentication_template/review_request.html', context)

@login_required
def get_department_teachers(request):
    department_id = request.GET.get('department_id')
    teachers = Teacher.objects.filter(department_id=department_id).values('id', 'name', 'teacher_code')
    return JsonResponse(list(teachers), safe=False)

@login_required
def student_request_attendance_change(request):
    """View for students to request attendance changes"""
    if request.user.role != 'student':
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')
    
    try:
        student = request.user
        # Get the student's enrollment record
        student_enrollment = EnrollStudent.objects.get(user=student)
        
        # Get all courses the student is enrolled in
        enrolled_courses = student_enrollment.courses.all()
        
        # Get student record
        student_instance = Student.objects.get(
            name=f"{student.first_name} {student.last_name}",
            department=student_enrollment.department,
            program=student_enrollment.program,
            semester=student_enrollment.semester
        )
        
        # Get recent attendance records (last 7 days)
        recent_date = timezone.now().date() - timezone.timedelta(days=7)
        recent_attendance = Attendance.objects.filter(
            student=student_instance,
            course__in=enrolled_courses,
            date__gte=recent_date
        ).select_related('course').order_by('-date', '-marked_at')
        
        # Check which records are within the 1-hour window for change requests
        # and filter out records older than 1 hour
        one_hour_attendance = []
        for record in recent_attendance:
            time_diff = timezone.now() - record.marked_at
            time_diff_seconds = time_diff.total_seconds()
            record.can_request_change = time_diff_seconds <= 3600  # 1 hour in seconds
            
            # Only include records within the 1-hour window
            if record.can_request_change:
                # Check if a request already exists
                record.has_pending_request = AttendanceChangeRequest.objects.filter(
                    student=student_instance,
                    course=record.course,
                    date=record.date,
                    status='pending'
                ).exists()
                one_hour_attendance.append(record)
        
        context = {
            'attendance_records': one_hour_attendance,
            'student': student,
            'student_instance': student_instance
        }
        
        return render(request, 'attendance/student_authentication_template/request_attendance_change.html', context)
        
    except EnrollStudent.DoesNotExist:
        messages.error(request, "Your enrollment record was not found. Please contact the administrator.")
        return redirect('student_dashboard')
    except Student.DoesNotExist:
        messages.error(request, "Your student record was not found. Please contact the administrator.")
        return redirect('student_dashboard')
    except Exception as e:
        messages.error(request, f"Error loading attendance records: {str(e)}")
        return redirect('student_dashboard')

@login_required
def submit_attendance_change_request(request):
    """Handle submission of attendance change requests from students"""
    if request.user.role != 'student':
        messages.error(request, "Access denied. This page is for students only.")
        return redirect('home')
    
    if request.method != 'POST':
        return redirect('student_request_attendance_change')
    
    try:
        # Get form data
        attendance_id = request.POST.get('attendance_id')
        reason_choice = request.POST.get('reason')
        additional_details = request.POST.get('additional_details', '')
        
        # Get attendance record
        attendance = Attendance.objects.get(id=attendance_id)
        
        # Check if within time limit (1 hour)
        time_diff = timezone.now() - attendance.marked_at
        if time_diff.total_seconds() > 3600:
            messages.error(request, "Attendance change requests must be submitted within 1 hour of attendance marking.")
            return redirect('student_request_attendance_change')
        
        # Check if request already exists
        if AttendanceChangeRequest.objects.filter(
            student=attendance.student,
            course=attendance.course,
            date=attendance.date,
            status='pending'
        ).exists():
            messages.error(request, "A pending request already exists for this attendance record.")
            return redirect('student_request_attendance_change')
        
        # Create the change request
        requested_status = 'Present' if attendance.status == 'Absent' else 'Absent'
        reason_text = f"{reason_choice}: {additional_details}" if additional_details else reason_choice
        
        change_request = AttendanceChangeRequest.objects.create(
            student_user=request.user,
            student=attendance.student,
            course=attendance.course,
            date=attendance.date,
            old_status=attendance.status,
            requested_status=requested_status,
            reason=reason_text,
            status='pending'
        )
        
        # Notify teachers assigned to this course
        course_teachers = CourseTeacher.objects.filter(course=attendance.course)
        for teacher in course_teachers:
            Notification.objects.create(
                user=teacher.user,
                title=f"Attendance Change Request",
                message=f"Student {attendance.student.name} has requested to change attendance status from {attendance.status} to {requested_status} for {attendance.course.name} on {attendance.date}.",
                notification_type='request',
                is_read=False
            )
        
        messages.success(request, "Attendance change request submitted successfully. You will be notified when it is processed.")
        return redirect('student_dashboard')
        
    except Attendance.DoesNotExist:
        messages.error(request, "Attendance record not found.")
        return redirect('student_request_attendance_change')
    except Exception as e:
        messages.error(request, f"Error submitting request: {str(e)}")
        return redirect('student_request_attendance_change')

@login_required
def approve_attendance_change(request, request_id):
    """Approve a student's attendance change request"""
    if request.user.role != 'faculty':
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')
    
    try:
        # Get the change request
        change_request = get_object_or_404(AttendanceChangeRequest, id=request_id, status='pending')
        
        # Verify the teacher is assigned to this course
        is_assigned = CourseTeacher.objects.filter(
            user=request.user,
            course=change_request.course
        ).exists()
        
        if not is_assigned:
            messages.error(request, "You are not authorized to approve this request.")
            return redirect('teacher_dashboard')
        
        # Check if within time limit (1 hour)
        if not change_request.is_within_time_limit():
            messages.error(request, "This request can no longer be approved as it exceeds the 1-hour time limit.")
            change_request.status = 'rejected'
            change_request.decision = f"Automatically rejected due to exceeding the 1-hour time limit."
            change_request.save()
            return redirect('teacher_dashboard')
        
        # Update attendance record - use filter().first() instead of get()
        attendance = Attendance.objects.filter(
            student=change_request.student,
            course=change_request.course,
            date=change_request.date
        ).first()
        
        if not attendance:
            messages.error(request, "Attendance record not found.")
            return redirect('teacher_dashboard')
        
        # Store old status for audit
        old_status = attendance.status
        
        # Update attendance status
        attendance.status = change_request.requested_status
        attendance.save()
        
        # Notify student
        Notification.objects.create(
            user=change_request.student_user,
            title=f"Attendance Change Request Approved",
            message=f"Your request to change attendance status for {change_request.course.name} on {change_request.date} has been approved. Changed from {old_status} to {change_request.requested_status}.",
            notification_type='general',
            is_read=False
        )
        
        # Delete the request record
        change_request.delete()
        
        messages.success(request, "Attendance change request approved and record updated successfully.")
        return redirect('teacher_dashboard')
        
    except AttendanceChangeRequest.DoesNotExist:
        messages.error(request, "Request not found.")
        return redirect('teacher_dashboard')
    except Exception as e:
        messages.error(request, f"Error approving request: {str(e)}")
        return redirect('teacher_dashboard')

@login_required
def reject_attendance_change(request, request_id):
    """Reject a student's attendance change request"""
    if request.user.role != 'faculty':
        messages.error(request, "Access denied. This page is for teachers only.")
        return redirect('home')
    
    try:
        # Get the change request
        change_request = get_object_or_404(AttendanceChangeRequest, id=request_id, status='pending')
        
        # Verify the teacher is assigned to this course
        is_assigned = CourseTeacher.objects.filter(
            user=request.user,
            course=change_request.course
        ).exists()
        
        if not is_assigned:
            messages.error(request, "You are not authorized to reject this request.")
            return redirect('teacher_dashboard')
        
        # Update request status
        change_request.status = 'rejected'
        change_request.decision = f"Rejected by {request.user.get_full_name()} on {timezone.now().strftime('%Y-%m-%d %H:%M:%S')}."
        change_request.save()
        
        # Notify student
        Notification.objects.create(
            user=change_request.student_user,
            title=f"Attendance Change Request Rejected",
            message=f"Your request to change attendance status for {change_request.course.name} on {change_request.date} has been rejected.",
            notification_type='general',
            is_read=False
        )
        
        messages.success(request, "Attendance change request rejected successfully.")
        return redirect('teacher_dashboard')
        
    except AttendanceChangeRequest.DoesNotExist:
        messages.error(request, "Request not found.")
        return redirect('teacher_dashboard')
    except Exception as e:
        messages.error(request, f"Error rejecting request: {str(e)}")
        return redirect('teacher_dashboard')